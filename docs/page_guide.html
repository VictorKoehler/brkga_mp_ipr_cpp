<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Guide / Tutorial &mdash; BRKGA-MP-IPR 3.0.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom_theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/doxyrest-pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/doxyrest-sphinx_rtd_theme.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=acc74ff5"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="_static/add_target.js?v=0b007391"></script>
        <script src="_static/target-highlight.js?v=df7d332b"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="BRKGA-MP-IPR License" href="page_license.html" />
    <link rel="prev" title="BRKGA-MP-IPR Guide and Documentation - C++ Version 3.0" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BRKGA-MP-IPR
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Guide / Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tl-dr-single-objective">TL;DR - Single objective</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tl-dr-multi-objective">TL;DR - Multi objective</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="#first-things-first">First things first</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-decoder-function">The decoder function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-chromosome-or-vector-of-doubles">The chromosome or vector of doubles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#back-to-the-decoder">Back to the decoder</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-brkga-mp-ipr-algorithm-object">Building BRKGA-MP-IPR algorithm object</a></li>
<li class="toctree-l2"><a class="reference internal" href="#it-s-optimization-time">It’s optimization time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#options-before-optimization-starts">Options before optimization starts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#setting-solution-observers-callbacks">Setting solution observers / callbacks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-custom-stopping-criteria">Defining custom stopping criteria</a></li>
<li class="toctree-l4"><a class="reference internal" href="#providing-custom-shake-procedure">Providing custom shake procedure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setting-custom-bias-function">Setting custom bias function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#injecting-warm-start-solutions">Injecting warm-start solutions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#diy-building-an-optimization-loop-for-fine-control">DIY: building an optimization loop for fine control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#evolving-the-population">Evolving the population</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-solutions-chromosomes">Accessing solutions/chromosomes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#injecting-solutions-chromosome-into-the-population">Injecting solutions / chromosome into the population</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implicit-path-relink">Implicit Path Relink</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#important-notes-about-ipr">Important notes about IPR</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#shaking">Shaking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#resetting">Resetting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-population-and-migration">Multi-population and migration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#simulating-the-standard-brkga">Simulating the standard BRKGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reading-and-writing-parameters">Reading and writing parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-brkga-mp-ipr-on-multi-objective-mode">Using BRKGA-MP-IPR on multi-objective mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#probable-valuable-tips">(Probable Valuable) Tips</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#algorithm-warmup">Algorithm warmup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complex-decoders-and-timing">Complex decoders and timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-thread-decoding">Multi-thread decoding</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-thread-mating">Multi-thread mating</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#known-issues">Known issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="page_license.html">BRKGA-MP-IPR License</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_todo.html">Todo List</a></li>
<li class="toctree-l1"><a class="reference internal" href="page_contributing.html">Contributing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="global.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BRKGA-MP-IPR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Guide / Tutorial</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/page_guide.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="guide-tutorial">
<span id="doxid-guide"></span><span id="index-0"></span><h1>Guide / Tutorial<a class="headerlink" href="#guide-tutorial" title="Link to this heading"></a></h1>
<p>This tutorial is based on the single objective function usage of BRKGA.
However, almost all information also applies to the multi-objective mode with
minimal changes, as explained in Section
<a class="reference internal" href="#doxid-guide-guide-multi-obj"><span class="std std-ref">Using BRKGA-MP on multi-objective mode</span></a>.</p>
<p>If you desire to understand the deeps of the multi-parenting and the implicity
path relink, read <span id="id1">[<a class="reference internal" href="#id34" title="Carlos E. Andrade, Rodrigo F. Toso, José F. Gonçalves, and Mauricio G. C. Resende. The multi-parent biased random-key genetic algorithm with implicit path-relinking and its real-world applications. European Journal of Operational Research, 289(1):17–30, 2021. doi:10.1016/j.ejor.2019.11.037.">ATGR21</a>]</span>.</p>
<section id="installation">
<span id="doxid-guide-installation"></span><h2>Installation<a class="headerlink" href="#installation" title="Link to this heading"></a></h2>
<p>BRKGA-MP-IPR is a header-only framework, which means that you only need to
download the header files and tell your compiler to include the path to where
the files were downloaded.</p>
<p>Quick example (unix): assume we are in an empty folder. So, we copy/clone
BRKGA-IPR-MP first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ git clone --depth 1 https://github.com/ceandrade/brkga_mp_ipr_cpp
Cloning into &#39;brkga_mp_ipr_cpp&#39;...
remote: Enumerating objects: 283, done.
remote: Counting objects: 100% (283/283), done.
remote: Compressing objects: 100% (222/222), done.
remote: Total 283 (delta 86), reused 180 (delta 55), pack-reused 0
Receiving objects: 100% (283/283), 6.77 MiB | 5.88 MiB/s, done.
Resolving deltas: 100% (86/86), done.
</pre></div>
</div>
<p>Let’s write a <code class="docutils literal notranslate"><span class="pre">test.cpp</span></code> with the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="cp">#include</span> <span class="cpf">&quot;brkga_mp_ipr.hpp&quot;</span>
<span class="linenos">2</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span>
<span class="linenos">3</span>
<span class="linenos">4</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="linenos">5</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Testing sense: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">Sense</span><span class="o">::</span><span class="n">MINIMIZE</span><span class="p">;</span>
<span class="linenos">6</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="linenos">7</span><span class="p">}</span>
</pre></div>
</div>
<p>Then, let’s compile with <a class="reference external" href="https://gcc.gnu.org">GCC</a> and see it works:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ g++ --version
g++ (MacPorts gcc12 12.3.0_0+stdlib_flag) 12.3.0
Copyright (C) 2022 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

$ g++ -std=c++20 -Ibrkga_mp_ipr_cpp/brkga_mp_ipr test.cpp -o test

$ ./test
Testing sense: MINIMIZE
</pre></div>
</div>
<p>With <a class="reference external" href="https://clang.llvm.org">Clang</a> (note that we have to use the flag
<code class="docutils literal notranslate"><span class="pre">-fopenmp</span></code>, otherwise we get compilation errors):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ clang++ --version
clang version 16.0.6
Target: x86_64-apple-darwin22.6.0
Thread model: posix
InstalledDir: /opt/local/libexec/llvm-16/bin

$ clang++ -std=c++20 -fopenmp -Ibrkga_mp_ipr_cpp/brkga_mp_ipr test.cpp -o test

$ ./test
Testing sense: MINIMIZE
</pre></div>
</div>
<p>Note the Git clones the whole repository that contains the library code,
documents, and examples. All the examples were built using <a class="reference external" href="https://www.gnu.org/software/make">GNU/Make</a>, and <a class="reference external" href="https://gcc.gnu.org">GCC toolchain</a> or <a class="reference external" href="https://clang.llvm.org">LLVM/Clang toolchain</a>.
However, the code is standard C++, and we can
quickly adapt it to other toolchains such as <a class="reference external" href="https://visualstudio.microsoft.com">Microsoft</a>, or <a class="reference external" href="https://software.intel.com/en-us/c-compilers">Intel</a> toolchains.</p>
</section>
<section id="tl-dr-single-objective">
<span id="doxid-guide-guide-tldr-single-obj"></span><h2>TL;DR - Single objective<a class="headerlink" href="#tl-dr-single-objective" title="Link to this heading"></a></h2>
<p>The best way to keep it short is to look in the on examples on <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/tree/master/examples">the git repo.</a>
Let’s start solving the traditional single-objective <a class="reference external" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Traveling Salesman
Problem (TSP)</a>.
First, we must ensure that
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ae212772a5d4bb9b7055e30791b494514"><span class="std std-ref"><span class="pre">BRKGA::fitness_t</span></span></a></code>
has the right single-object type. Let’s
take a look at the trimmed version of
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/brkga_mp_ipr/fitness_type.hpp">fitness_type.hpp</a>.
This is a trimmed copy:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">namespace</span> <span class="n">BRKGA</span> <span class="p">{</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="k">using</span> <span class="n">fitness_t</span> <span class="o">=</span> <span class="kt">double</span><span class="p">;</span>
<span class="linenos">4</span>
<span class="linenos">5</span><span class="c1">//...</span>
<span class="linenos">6</span><span class="p">}</span> <span class="c1">// end namespace BRKGA_MP_IPR</span>
</pre></div>
</div>
<p>Here,
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ae212772a5d4bb9b7055e30791b494514"><span class="std std-ref"><span class="pre">BRKGA::fitness_t</span></span></a></code>
defines the type of the objective function value. In the vast
majority of the cases, <code class="docutils literal notranslate"><span class="pre">double</span></code> suffices. Let’s take a look into the main call
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/main_minimal.cpp">main_minimal.cpp</a>.
This is a trimmed copy:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="linenos"> 2</span>    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 3</span>        <span class="n">cerr</span>
<span class="linenos"> 4</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot;Usage: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="linenos"> 5</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot; &lt;seed&gt; &lt;config-file&gt; &lt;maximum-running-time&gt;&quot;</span>
<span class="linenos"> 6</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot; &lt;tsp-instance-file&gt;&quot;</span>
<span class="linenos"> 7</span>        <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 8</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="linenos"> 9</span>    <span class="p">}</span>
<span class="linenos">10</span>
<span class="linenos">11</span>    <span class="k">try</span> <span class="p">{</span>
<span class="linenos">12</span>        <span class="c1">// Read command-line arguments and the instance</span>
<span class="linenos">13</span>        <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="linenos">14</span>        <span class="k">const</span> <span class="n">string</span> <span class="n">config_file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="linenos">15</span>        <span class="k">const</span> <span class="n">string</span> <span class="n">instance_file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="linenos">16</span>        <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="linenos">17</span>
<span class="linenos">18</span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Reading data...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="linenos">19</span>        <span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">TSP_Instance</span><span class="p">(</span><span class="n">instance_file</span><span class="p">);</span>
<span class="linenos">20</span>
<span class="linenos">21</span>        <span class="c1">// Read algorithm parameters</span>
<span class="linenos">22</span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Reading parameters...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="linenos">23</span>
<span class="linenos">24</span>        <span class="k">auto</span> <span class="p">[</span><span class="n">brkga_params</span><span class="p">,</span> <span class="n">control_params</span><span class="p">]</span> <span class="o">=</span>
<span class="linenos">25</span>            <span class="n">BRKGA</span><span class="o">::</span><span class="n">readConfiguration</span><span class="p">(</span><span class="n">config_file</span><span class="p">);</span>
<span class="linenos">26</span>
<span class="linenos">27</span>        <span class="c1">// Overwrite the maximum time from the config file.</span>
<span class="linenos">28</span>        <span class="n">control_params</span><span class="p">.</span><span class="n">maximum_running_time</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span> <span class="p">{</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])};</span>
<span class="linenos">29</span>
<span class="linenos">30</span>        <span class="c1">// Build the BRKGA data structure</span>
<span class="linenos">31</span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Building BRKGA data and initializing...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="linenos">32</span>
<span class="linenos">33</span>        <span class="n">TSP_Decoder</span> <span class="n">decoder</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
<span class="linenos">34</span>
<span class="linenos">35</span>        <span class="n">BRKGA</span><span class="o">::</span><span class="n">BRKGA_MP_IPR</span><span class="o">&lt;</span><span class="n">TSP_Decoder</span><span class="o">&gt;</span> <span class="n">algorithm</span><span class="p">(</span>
<span class="linenos">36</span>            <span class="n">decoder</span><span class="p">,</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">Sense</span><span class="o">::</span><span class="n">MINIMIZE</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span>
<span class="linenos">37</span>            <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">,</span> <span class="n">num_threads</span>
<span class="linenos">38</span>        <span class="p">);</span>
<span class="linenos">39</span>
<span class="linenos">40</span>        <span class="c1">// Find good solutions / evolve</span>
<span class="linenos">41</span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Running for &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">control_params</span><span class="p">.</span><span class="n">maximum_running_time</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;...&quot;</span>
<span class="linenos">42</span>             <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="linenos">43</span>
<span class="linenos">44</span>        <span class="k">const</span> <span class="k">auto</span> <span class="n">final_status</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">control_params</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cout</span><span class="p">);</span>
<span class="linenos">45</span>
<span class="linenos">46</span>        <span class="n">cout</span>
<span class="linenos">47</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Algorithm status: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">final_status</span>
<span class="linenos">48</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">Best cost: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">final_status</span><span class="p">.</span><span class="n">best_fitness</span>
<span class="linenos">49</span>        <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="linenos">50</span>    <span class="p">}</span>
<span class="linenos">51</span>    <span class="k">catch</span><span class="p">(</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">52</span>        <span class="n">cerr</span>
<span class="linenos">53</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">string</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="linenos">54</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot;Exception Occurred: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span>
<span class="linenos">55</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">string</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="sc">&#39;*&#39;</span><span class="p">)</span>
<span class="linenos">56</span>        <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="linenos">57</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="linenos">58</span>    <span class="p">}</span>
<span class="linenos">59</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="linenos">60</span><span class="p">}</span>
</pre></div>
</div>
<p>You can identify the following basic steps:</p>
<ol class="arabic simple">
<li><p>Create a data structure to hold your input data. This object should be
passed to the decoder object/functor (example
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/tsp/tsp_instance.hpp">tsp/tsp_instance.hpp</a>);</p></li>
<li><p>Certify that
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ae212772a5d4bb9b7055e30791b494514"><span class="std std-ref"><span class="pre">BRKGA::fitness_t</span></span></a></code>
has the correct type;</p></li>
<li><p>Implement a decoder object/functor. This function translates a chromosome
(array of numbers in the interval [0, 1)) to a solution for your problem.
The decoder must return the solution value or cost to be used as fitness by
BRKGA (example <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/decoders/tsp_decoder.hpp">decoders/tsp_decoder.hpp</a>);</p></li>
<li><p>Load the instance and other relevant data;</p></li>
<li><p>Read the algorithm parameters using
<code class="docutils literal notranslate"><a class="reference internal" href="group_brkga_control_params.html#doxid-group-brkga-control-params-1ga1c8b456ad75a3b522d315d4167546ae6"><span class="std std-ref"><span class="pre">BRKGA::readConfiguration()</span></span></a></code>;
or create
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">BRKGA::ControlParams</span></span></a></code>
objects by hand;</p></li>
<li><p>Create an <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code> algorithm object;</p></li>
<li><p>Call <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::run()</span></span></a></code>
to optimize;</p></li>
<li><p>Check the resulting <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_AlgorithmStatus.html#doxid-class-b-r-k-g-a-1-1-algorithm-status"><span class="std std-ref"><span class="pre">BRKGA::AlgorithmStatus</span></span></a></code>
for optimization information.</p></li>
</ol>
<p><a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/main_minimal.cpp">main_minimal.cpp</a>
provides a very minimal example to understand the necessary steps to use the
BRKGA-MP-IPR framework. However,
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/main_complete.cpp">main_complete.cpp</a>
provides a full-featured code, handy for scientific use, such as
experimentation and paper writing. This code allows fine-grained control of
the optimization, shows several features of BRKGA-MP-IPR such as the resets,
chromosome injection, and others. It also logs
all optimization steps, <em>creating outputs easy to be parsed.</em> <strong>You should use
this code for serious business and experimentation.</strong></p>
<p>These are the basic steps, but I do recommend the reading of this guide.</p>
</section>
<section id="tl-dr-multi-objective">
<span id="doxid-guide-guide-tldr-multi-obj"></span><h2>TL;DR - Multi objective<a class="headerlink" href="#tl-dr-multi-objective" title="Link to this heading"></a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Remember, BRKGA-MP-IPR multi-objective mode produces <strong>lexicographical
dominated solutions</strong> but <strong>no non-dominated solutions</strong> (Pareto frontier).
Please, see the details in the <a class="reference internal" href="index.html#doxid-indexpage"><span class="std std-ref">introduction</span></a>.</p>
</div>
<p>To use BRKGA-MP-IPR in the multi-objective mode, we first must set
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ae212772a5d4bb9b7055e30791b494514"><span class="std std-ref"><span class="pre">BRKGA::fitness_t</span></span></a></code>
according to the number of objectives we want. In the
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/tree/master/examples/tsp/src/multi_obj">repo example,</a>
we consider the TSP with two objectives: first, we must minimize the total tour
length, and second, the size of the largest edge in the tour. For that, we must
change the file
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/brkga_mp_ipr/fitness_type.hpp">fitness_type.hpp</a>
to reflect such a thing. In this example, we use the standard
<a class="reference external" href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">namespace</span> <span class="n">BRKGA</span> <span class="p">{</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="k">using</span> <span class="n">fitness_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="linenos">4</span>
<span class="linenos">5</span><span class="c1">//...</span>
<span class="linenos">6</span><span class="p">}</span> <span class="c1">// end namespace BRKGA_MP_IPR</span>
</pre></div>
</div>
<p>In this case, the first component of the tuple holds the tour length, and the
second contains the largest edge. On Section
<a class="reference internal" href="#doxid-guide-guide-multi-obj"><span class="std std-ref">Using BRKGA-MP on multi-objective mode</span></a>,
we talk with more details about multi-objective problems. Just keep in mind,
although you could use any type for your <cite>fitness_t</cite>, you should prefer to use
<a class="reference external" href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>.</p>
<p>The remaining code is almost identical to the single-objective. The only
differences are in computing the largest edge, and printing such information on
the main call. All the steps described briefly in the
<a class="reference internal" href="#doxid-guide-guide-tldr-single-obj"><span class="std std-ref">previous section</span></a>
are also used here.</p>
</section>
<section id="getting-started">
<span id="doxid-guide-getting-started"></span><h2>Getting started<a class="headerlink" href="#getting-started" title="Link to this heading"></a></h2>
<p>BRKGA-MP-IPR is pretty simple, and you must provide one required <em>decoder</em>
object to translate chromosomes to solutions. In general, such decoder uses
the problem information to map a vector of real numbers in the interval [0, 1)
to a (valid) solution. In some cases, even though a valid solution cannot be
found, library users apply penalization factors and push the BRKGA to find
valid solutions.</p>
<p>Before you go further, please take a look at the <code class="docutils literal notranslate"><span class="pre">examples</span></code> folder in <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp">the
git repo</a>.
Until version 2.0, we maintained a folder with code to solve
combinatorial auction problems <span id="id5">[<a class="reference internal" href="#id41" title="Carlos E. Andrade, Rodrigo F. Toso, Mauricio G. C. Resende, and Flávio K. Miyazawa. Biased random-key genetic algorithms for the winner determination problem in combinatorial auctions. Evolutionary Computation, 23:279–307, 2015. doi:10.1162/EVCO_a_00138.">ATRM15</a>]</span>.
But due to maintanance burden,
we drop the that code from the repo. However, the classical
<a class="reference external" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Traveling Salesman Problem (TSP)</a> was kept.
In the TSP, we have a set of cities and the distances between them (full
weighted undirect graph). One must find a minimum-cost tour among all cities,
such that each city is visited only once (i.e., find a Hamiltonian cycle of
minimum cost). The folder has the following structure:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">src</span></code> subdir: contains all the code;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">instances</span></code> subdir: folder containing some TSP instances for testing;</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">src</span></code> subdir contains all the code to solve TSP both for single and
multi-objective. This is its structure:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tsp</span></code> subdir: contains code to load and build data for TSP;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">decoders</span></code> subdir: contains the TSP decoder;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">heuristics</span></code> subdir: contains a simple heuristic that computes a greedy
tour;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">main_minimal.cpp</span></code> file: minimal code useful to understand and test the
framework. <strong>You should start here!</strong> Please take a look on this file before
continue this tutorial;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">main_complete.cpp</span></code> file: full-featured code, handy for scientific use,
such as experimentation and paper writing. This code allows fine-grained
control of the optimization, shows several features of BRKGA-MP-IPR such as
the path-relinking calls, resets, chromosome injection, and others. It also
logs all optimization steps, <em>creating outputs easy to be parsed.</em>
<strong>You should use this code for serious business and experimentation;</strong>
Note that this version was much simplified from version 2.0. Still, it offers
a lot of control for experimentation through parameter tuning. However,
it is still possible to decompose it by inspecting the code on method
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::run()</span></span></a></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">config.conf</span></code> file: example of parameter settings;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Makefile</span></code> file: the makefile used to build the executables;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">third_part</span></code> subdir: contains the <a class="reference external" href="https://github.com/docopt/docopt.cpp">docopt</a>
dependence for <code class="docutils literal notranslate"><span class="pre">main_complete.cpp</span></code>. This is not strictly necessary for
BRKGA-MP-IPR, but it adds a nice command line interface. If you have problems
with that, we can change <code class="docutils literal notranslate"><span class="pre">main_complete.cpp</span></code> using traditional argument
handling, or another library you prefer.</p></li>
</ul>
<p>The first step is to build the code. Here, we are using <a class="reference external" href="https://www.gnu.org/software/make">GNU/Make</a> and <a class="reference external" href="https://gcc.gnu.org">GCC toolchain</a>. You may change for the toolchain of your choice.
You may need to edit this file according to your compiler version and
settings. The first thing to note in the makefile is the parameter <code class="docutils literal notranslate"><span class="pre">OPT</span></code>
that, when set <code class="docutils literal notranslate"><span class="pre">OPT=opt</span></code>, it turns on aggressive optimization flags (for
G++). If the flag is not set, aggressive debug options are set. For serious
implementations, and debugging, we do recommend to use such setup. However,
if your compiler does not like such settings, please, go ahead and change
accordingly. By typing just <code class="docutils literal notranslate"><span class="pre">make</span></code>, you build both minimal and complete
versions. We also can just type <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">main_minimal</span></code> or <code class="docutils literal notranslate"><span class="pre">make</span>
<span class="pre">main_complete</span></code> to build one or other version independently.
Typing <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">clean</span></code> will clean up the compilation.</p>
<p>When you call the executables <code class="docutils literal notranslate"><span class="pre">main_minimal</span></code> or <code class="docutils literal notranslate"><span class="pre">main_complete</span></code> without
arguments, they show the usage. For example, assuming you are using a
terminal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$./main_minimal
Usage: ./main_minimal &lt;seed&gt; &lt;config-file&gt; &lt;maximum-running-time&gt; &lt;tsp-instance-file&gt;

$ ./main_complete
Arguments did not match expected patterns

Usage:
  main_complete
        --config &lt;config_file&gt;
        --seed &lt;seed&gt;
        --stop_rule &lt;stop_rule&gt;
        --stop_arg &lt;stop_arg&gt;
        --maxtime &lt;max_time&gt;
        --instance &lt;instance_file&gt;
        [--threads &lt;num_threads&gt;]
        [--no_evolution]
  main_complete (-h | --help)

Options:
  --config &lt;arg&gt;     Text file with the BRKGA-MP-IPR parameters.
  --seed &lt;arg&gt;       Seed for the random number generator.
  --stop_rule &lt;arg&gt;  Stop rule where:
                     - (G)enerations: number of evolutionary generations.
                     - (I)terations: maximum number of generations without
                       improvement in the solutions.
  --stop_arg &lt;arg&gt;     Argument value for the stopping rule.
  --maxtime &lt;arg&gt;      Maximum time in seconds.
  --instance &lt;arg&gt;     Instance file.
  --threads &lt;arg&gt;    Number of threads to be used during parallel decoding.
                     It must in the range [1, 64] [default: 1].
  --no_evolution     If supplied, no evolutionary operators are applied.
                     So, the algorithm becomes a simple multi-start algorithm.
  -h --help          Produce help message.
</pre></div>
</div>
<p>So, this is a possible output whe calling <code class="docutils literal notranslate"><span class="pre">main_minimal</span></code> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./main_minimal 27000001 config.conf 100 ../instances/brazil58.dat
Reading data...
Reading parameters...
Building BRKGA data and initializing...
Running for 30s...
Custom stopping criteria not supplied by the user. Using max. time = 30s and max. stall_offset = 1000
Using 4 threads for decoding
Exchanged 1 solutions from each population. Iteration 432. Current time: 7.88959s
Exchanged 1 solutions from each population. Iteration 556. Current time: 10.1435s
Exchanged 1 solutions from each population. Iteration 735. Current time: 13.1668s
Path relink at 835 iteration. Block size: 45. Type: DIRECT. Distance: KENDALLTAU. Current time: 13.1668s
- No improvement found. Current time: 14.7002s
Exchanged 1 solutions from each population. Iteration 835. Current time: 14.7006s
Exchanged 1 solutions from each population. Iteration 935. Current time: 16.3598s
Shaking with intensity 0.70553. Type SWAP. Iteration 935. Current time: 16.3598s
Path relink at 1035 iteration. Block size: 45. Type: DIRECT. Distance: KENDALLTAU. Current time: 16.3598s
- Improvement on the elite set but not in the best individual. Current time: 18.0657s
Exchanged 1 solutions from each population. Iteration 1035. Current time: 18.0661s
Exchanged 1 solutions from each population. Iteration 1135. Current time: 20.1444s
Reset population after 500 iterations without improvement. Iteration 1135. Current time: 20.1551s
Path relink at 1235 iteration. Block size: 45. Type: DIRECT. Distance: KENDALLTAU. Current time: 20.1551s
- No improvement found. Current time: 22.0121s
Exchanged 1 solutions from each population. Iteration 1235. Current time: 22.0125s
Shaking with intensity 0.635298. Type SWAP. Iteration 1235. Current time: 22.0125s
Exchanged 1 solutions from each population. Iteration 1335. Current time: 23.5627s
Path relink at 1435 iteration. Block size: 45. Type: DIRECT. Distance: KENDALLTAU. Current time: 23.5627s
- No improvement found. Current time: 25.0922s
Exchanged 1 solutions from each population. Iteration 1435. Current time: 25.0926s
Exchanged 1 solutions from each population. Iteration 1535. Current time: 26.6116s
Shaking with intensity 0.447978. Type SWAP. Iteration 1535. Current time: 26.6116s

Algorithm status:
best_fitness: 27895
current_iteration: 1635
last_update_iteration: 635
current_time: 28.1722s
last_update_time: 11.6496s
largest_iteration_offset: 159
stalled_iterations: 1000
path_relink_time: 0.076028s
num_path_relink_calls: 4
num_homogenities: 0
num_best_improvements: 0
num_elite_improvements: 1
num_exchanges: 11
num_shakes: 3
num_resets: 1

Best cost: 27895
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">main_complete</span></code>, the output is more verbose, since we want to capture
as much information as possible to do some statistical analysis. The output
should be something close to this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$./main_complete --config config.conf --seed 2700001 --stop_rule I \
    --stop_arg 1000 --maxtime 30 --threads 4 --instance ../../instances/brazil58.dat

[Tue Sep 26 22:13:30 2023] Experiment started
&gt; Instance: &#39;../../instances/brazil58.dat&#39;
&gt; Loading config file: &#39;config.conf&#39;
&gt; Algorithm parameters:
population_size 2000
elite_percentage 0.30
mutants_percentage 0.15
num_elite_parents 2
total_parents 3
bias_type LOGINVERSE
num_independent_populations 3
pr_number_pairs 0
pr_minimum_distance 0.15
pr_type DIRECT
pr_selection BESTSOLUTION
pr_distance_function_type KENDALLTAU
alpha_block_size 1.00
pr_percentage 1.00
num_exchange_individuals 1
shaking_type SWAP
shaking_intensity_lower_bound 0.25
shaking_intensity_upper_bound 0.75
&gt; Control parameters:
maximum_running_time 30s
exchange_interval 100
shake_interval 300
ipr_interval 200
reset_interval 500
stall_offset 1000
&gt; Seed: 2700001
&gt; Stop rule: Improvement
&gt; Stop argument: 1000
&gt; Number of threads for decoding: 4

[Tue Sep 26 22:13:30 2023] Reading TSP data
Number of nodes: 58

[Tue Sep 26 22:13:30 2023] Generating initial tour
Initial cost: 30774.00

[Tue Sep 26 22:13:30 2023] Building BRKGA
New population size: 580
Chromosome size: 58

[Tue Sep 26 22:13:30 2023] Injecting initial solution

[Tue Sep 26 22:13:30 2023] Optimizing...
* Iteration | Cost | CurrentTime
Custom stopping criteria not supplied by the user. Using max. time = 30s and max. stall_offset = 1000
Using 4 threads for decoding
* 1 | 30774.00 | 0.00s
* 46 | 30365.00 | 0.12s
* 47 | 29956.00 | 0.12s
* 53 | 29618.00 | 0.14s
* 54 | 29343.00 | 0.14s
* 71 | 29332.00 | 0.19s
* 115 | 29304.00 | 0.31s
* 145 | 29215.00 | 0.39s
* 156 | 29206.00 | 0.42s
* 167 | 29172.00 | 0.44s
Exchanged 1 solutions from each population. Iteration 267. Current time: 0.71s
* 364 | 29060.00 | 0.95s
* 370 | 28910.00 | 0.96s
Exchanged 1 solutions from each population. Iteration 470. Current time: 1.22s
* 474 | 28865.00 | 1.23s
* 477 | 28859.00 | 1.24s
* 554 | 28773.00 | 1.43s
* 596 | 28763.00 | 1.54s
* 647 | 28699.00 | 1.67s
* 675 | 28671.00 | 1.74s
* 746 | 28585.00 | 1.91s
* 760 | 28575.00 | 1.95s
Exchanged 1 solutions from each population. Iteration 860. Current time: 2.21s
* 932 | 28301.00 | 2.48s
Exchanged 1 solutions from each population. Iteration 1032. Current time: 2.81s
* 1080 | 28075.00 | 2.98s
* 1113 | 27945.00 | 3.12s
* 1165 | 27709.00 | 3.30s
* 1181 | 27571.00 | 3.35s
* 1184 | 27352.00 | 3.36s
* 1209 | 27294.00 | 3.44s
* 1220 | 27289.00 | 3.48s
Exchanged 1 solutions from each population. Iteration 1320. Current time: 3.79s
Path relink at 1420 iteration. Block size: 25. Type: DIRECT. Distance: KENDALLTAU. Current time: 3.79s
- No improvement found. Current time: 4.09s
Exchanged 1 solutions from each population. Iteration 1420. Current time: 4.09s
Exchanged 1 solutions from each population. Iteration 1520. Current time: 4.42s
Shaking with intensity 0.65. Type SWAP. Iteration 1520. Current time: 4.42s
Path relink at 1620 iteration. Block size: 25. Type: DIRECT. Distance: KENDALLTAU. Current time: 4.42s
- No improvement found. Current time: 4.73s
Exchanged 1 solutions from each population. Iteration 1620. Current time: 4.73s
Exchanged 1 solutions from each population. Iteration 1720. Current time: 5.04s
Reset population after 500 iterations without improvement. Iteration 1720. Current time: 5.04s
Path relink at 1820 iteration. Block size: 25. Type: DIRECT. Distance: KENDALLTAU. Current time: 5.04s
- No improvement found. Current time: 5.36s
Exchanged 1 solutions from each population. Iteration 1820. Current time: 5.36s
Shaking with intensity 0.73. Type SWAP. Iteration 1820. Current time: 5.36s
Exchanged 1 solutions from each population. Iteration 1920. Current time: 5.70s
Path relink at 2020 iteration. Block size: 25. Type: DIRECT. Distance: KENDALLTAU. Current time: 5.70s
- No improvement found. Current time: 5.98s
Exchanged 1 solutions from each population. Iteration 2020. Current time: 5.98s
Exchanged 1 solutions from each population. Iteration 2120. Current time: 6.26s
Shaking with intensity 0.26. Type SWAP. Iteration 2120. Current time: 6.26s

[Tue Sep 26 22:13:37 2023] End of optimization

&gt; Final status:
best_fitness: 27289.00
current_iteration: 2220
last_update_iteration: 1220
current_time: 6.54s
last_update_time: 3.48s
largest_iteration_offset: 197
stalled_iterations: 1000
path_relink_time: 0.01s
num_path_relink_calls: 4
num_homogenities: 0
num_best_improvements: 0
num_elite_improvements: 0
num_exchanges: 13
num_shakes: 3
num_resets: 1

% Best tour cost: 27289
% Best tour: 21 7 0 29 12 39 24 8 31 19 52 49 3 17 43 23 57 4 26 42 11 56 22 54 53 1 47 40 34 9 51 50 46 48 2 20 35 16 25 18 5 27 13 36 14 33 45 55 44 32 28 38 10 15 41 30 6 37

Instance,Seed,Cost,NumNodes,TotalIterations,LastUpdateIteration,TotalTime,LastUpdateTime,LargestIterationOffset,StalledIterations,PRTime,PRCalls,PRNumHomogenities,PRNumPrImprovBest,PRNumImprovElite,NumExchanges,NumShakes,NumResets
brazil58,2700001,27289,58,2220,1220,6.54,3.48,197,1000,0.01,4,0,0,0,13,3,1
</pre></div>
</div>
<p>Note that your can extract only the last line (e.g., using <code class="docutils literal notranslate"><span class="pre">tail</span> <span class="pre">-n1</span></code>)
from the log, and add it to a table in a CSV file. In this way, you can load
such table in your favorite statistic tools.</p>
<p>I hope by now you got your system set up and running. Let’s see the essential
details on how to use the BRKGA-MP-IPR.</p>
</section>
<section id="first-things-first">
<span id="doxid-guide-decoder-development"></span><h2>First things first<a class="headerlink" href="#first-things-first" title="Link to this heading"></a></h2>
<section id="the-decoder-function">
<span id="doxid-guide-decoder-function"></span><h3>The decoder function<a class="headerlink" href="#the-decoder-function" title="Link to this heading"></a></h3>
<p>The core of the BRKGA algorithm is the definition of a decoder
function/object. The decoder maps the chromosomes (vectors of real numbers in
the interval [0, 1)) to solutions of the problem. In some sense, a decoder is
similar to a <a class="reference external" href="https://en.wikipedia.org/wiki/Kernel_method">kernel function from Support Vector Machines</a>: both functions are used to
project solutions/distances in different spaces.</p>
<p>Here, we have a small difference between the C++/Python and the Julia
implementations. In the Julia version, you must define a data container
inherit from <a class="reference external" href="https://ceandrade.github.io/BrkgaMpIpr.jl/guide/#First-things-first:-basic-data-structures-and-decoder-function-1">AbstractInstance</a>,
and a decoder function. The reason you must do that is because structs in
Julia have no methods (but constructors), and the decoder function must take
both chromosome and input data in the call. In C++/Python, we can encapsulate the
input data into the decoder object, resulting in a much more clear API.</p>
<p>The basic form of a decoder should be:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">class</span> <span class="n">Decoder</span> <span class="p">{</span>
<span class="linenos">2</span><span class="k">public</span><span class="o">:</span>
<span class="linenos">3</span>    <span class="n">BRKGA</span><span class="o">::</span><span class="n">fitness_t</span> <span class="n">decode</span><span class="p">(</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">rewrite</span><span class="p">);</span>
<span class="linenos">4</span><span class="p">};</span>
</pre></div>
</div>
<p>The decoder <strong>must</strong> contain a public <strong>decode()</strong> method that receives a
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1a8ae7fc2da08d2d93a0628f346e72fab6"><span class="std std-ref"><span class="pre">BRKGA::Chromosome</span></span></a></code>
reference and an <code class="docutils literal notranslate"><span class="pre">boolean</span></code>, and returns a
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ae212772a5d4bb9b7055e30791b494514"><span class="std std-ref"><span class="pre">BRKGA::fitness_t</span></span></a></code>.
But before going further, let’s talk about the chromosome.</p>
</section>
<section id="the-chromosome-or-vector-of-doubles">
<span id="doxid-guide-the-chromosome"></span><h3>The chromosome or vector of doubles<a class="headerlink" href="#the-chromosome-or-vector-of-doubles" title="Link to this heading"></a></h3>
<p>Note that all long the BRKGA discussion, the chromosome is represented as a
vector of real numbers in the interval [0, 1). Indeed, we could use
straightforward <code class="docutils literal notranslate"><span class="pre">std::vector&lt;double&gt;</span></code>. However, sometimes is interesting to
keep more information inside the chromosome for further analysis, such as,
other solution metrics that not the main fitness value. For example, in a
scheduling problem, we may choose to keep both makespan and total completion
time metrics. Therefore, we chose to make the chromosome a “generic” data
structure in our design.</p>
<p>File
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/brkga_mp_ipr/chromosome.hpp">chomosome.hpp</a>
shows the basic represetation of a chromosome:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">Chromosome</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>If this enough for you, you go already and use such a definition.
<strong>We do recommend to import and use the definition from</strong>
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/brkga_mp_ipr/chromosome.hpp">chomosome.hpp</a>,
instead to redefine in your own code, since it is the same definition
the main BRKGA-MP-IPR algorithm uses.</p>
<p>However, if you need more information to be tracked during the optimization,
you can redefine the chromosome. First, your definition must complain with
the <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> interface. The easiest way to do that is to inherit
from the <code class="docutils literal notranslate"><span class="pre">std::vector</span></code>. For instance, assume we want to keep track of the
makespan and the total completion time for a scheduling problem. We can do
the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="nl">Chromosome</span><span class="p">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="linenos"> 2</span><span class="k">public</span><span class="o">:</span>
<span class="linenos"> 3</span>    <span class="n">Chromosome</span><span class="p">()</span> <span class="o">:</span>
<span class="linenos"> 4</span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">makespan</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">total_completion_time</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="linenos"> 5</span>        <span class="p">{}</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span>    <span class="n">Chromosome</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">_size</span><span class="p">,</span> <span class="kt">double</span> <span class="n">_value</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="linenos"> 8</span>        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_size</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span>
<span class="linenos"> 9</span>        <span class="n">makespan</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">total_completion_time</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="linenos">10</span>        <span class="p">{}</span>
<span class="linenos">11</span>
<span class="linenos">12</span>    <span class="n">Chromosome</span><span class="p">(</span><span class="k">const</span> <span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">chr</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="linenos">13</span>
<span class="linenos">14</span><span class="k">public</span><span class="o">:</span>
<span class="linenos">15</span>    <span class="kt">double</span> <span class="n">makespan</span><span class="p">;</span>
<span class="linenos">16</span>    <span class="kt">double</span> <span class="n">total_completion_time</span><span class="p">;</span>
<span class="linenos">17</span><span class="p">};</span>
</pre></div>
</div>
<p>In general, most people do not recommend to inherit publicly from
<code class="docutils literal notranslate"><span class="pre">std::vector</span></code> because it has no virtual destructor. However, we may do
that as long as:</p>
<ol class="loweralpha simple">
<li><p>We remember that every operation provided by <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> must be a
semantically valid operation on an object of the derived class;</p></li>
<li><p>We avoid creating derived class objects with dynamic storage duration;</p></li>
<li><p>We <strong>DO AVOID</strong> polymorphism:</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;*</span> <span class="n">pt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Chromosome</span><span class="p">();</span>     <span class="c1">// Bad idea. Don&#39;t do that!</span>
<span class="linenos">2</span><span class="k">delete</span> <span class="n">pt</span><span class="p">;</span>      <span class="c1">// Delete does not call the Chromosome destructor.</span>
</pre></div>
</div>
</section>
<section id="back-to-the-decoder">
<span id="doxid-guide-back-to-the-decoder"></span><h3>Back to the decoder<a class="headerlink" href="#back-to-the-decoder" title="Link to this heading"></a></h3>
<p>Again, <strong>the decoder is the heart of a BRKGA.</strong> An easy way to keep the API clean
is to define a decoder that has a reference for the input data. This is a TSP
decoder defined on file <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/decoders/tsp_decoder.hpp">decoders/tsp_decoder.hpp</a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span> <span class="cpf">&quot;tsp/tsp_instance.hpp&quot;</span>
<span class="linenos"> 2</span><span class="cp">#include</span> <span class="cpf">&quot;brkga_mp_ipr/fitness_type.hpp&quot;</span>
<span class="linenos"> 3</span><span class="cp">#include</span> <span class="cpf">&quot;brkga_mp_ipr/chromosome.hpp&quot;</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="k">class</span> <span class="n">TSP_Decoder</span> <span class="p">{</span>
<span class="linenos"> 6</span><span class="k">public</span><span class="o">:</span>
<span class="linenos"> 7</span>    <span class="n">TSP_Decoder</span><span class="p">(</span><span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">);</span>
<span class="linenos"> 8</span>    <span class="n">BRKGA</span><span class="o">::</span><span class="n">fitness_t</span> <span class="n">decode</span><span class="p">(</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">rewrite</span><span class="p">);</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="k">public</span><span class="o">:</span>
<span class="linenos">11</span>    <span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">;</span>
<span class="linenos">12</span><span class="p">};</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">TSP_Decoder</span></code> get a const reference to <code class="docutils literal notranslate"><span class="pre">TSP_Instance</span></code>, that holds
the input data. Therefore, <code class="docutils literal notranslate"><span class="pre">TSP_Decoder</span></code> has direct access to the data for
optimization. This approach also benefits cache efficiency, mainly when
multiple threads are used for decoding, i.e., several threads can use the same
read-only data already in the cache, which speeds up the optimization.</p>
<p>The decode method also has a <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> argument that indicates if the decoder
should rewrite the chromosome, in case of local search / local improvements be
performed during the decoder process. This flag is critical if you intend to
use the Implicit Path Relink (details on
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aa8da5193248d23ced19e68483aca31a5"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::pathRelink()</span></span></a></code>
Even though you do not rewrite the chromosome in your decoder, you must provide
such signature for API compatibility.</p>
<p>The decoder must return a
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ae212772a5d4bb9b7055e30791b494514"><span class="std std-ref"><span class="pre">BRKGA::fitness_t</span></span></a></code>
that is used as the <strong>fitness</strong> to rank the chromosomes. In general, fitness is
the cost/value of the solution, but you may want to use it to penalize
solutions that violate the problem constraints, for example.</p>
<p>In our TSP example, we have a very simple decoder that generates a permutation
of nodes, and compute the cost of the cycle from that permutation
(note that we don’t use the flag <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> in this example):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">fitness_t</span> <span class="n">TSP_Decoder</span><span class="o">::</span><span class="n">decode</span><span class="p">(</span><span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span> <span class="kt">bool</span> <span class="cm">/* not-used */</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 2</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;&gt;</span> <span class="n">permutation</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">);</span>
<span class="linenos"> 3</span>    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="linenos"> 4</span>        <span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">chromosome</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span>    <span class="n">sort</span><span class="p">(</span><span class="n">permutation</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">permutation</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span>    <span class="n">BRKGA</span><span class="o">::</span><span class="n">fitness_t</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">permutation</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">,</span>
<span class="linenos"> 9</span>                                              <span class="n">permutation</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">second</span><span class="p">);</span>
<span class="linenos">10</span>
<span class="linenos">11</span>    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="linenos">12</span>        <span class="n">cost</span> <span class="o">+=</span> <span class="n">instance</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">,</span>
<span class="linenos">13</span>                                  <span class="n">permutation</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
<span class="linenos">14</span>    <span class="k">return</span> <span class="n">cost</span><span class="p">;</span>
<span class="linenos">15</span><span class="p">}</span>
</pre></div>
</div>
<p>With the instance data and the decoder ready, we can build the BRKGA data
structures and perform the optimization.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When using multiple threads, <strong>you must guarantee that the decoder is
thread-safe.</strong> You may want to create all read-write data structures on each
call or create a separate storage space for each thread. Section
<a class="reference internal" href="#doxid-guide-guide-tips-multi-thread-decoding"><span class="std std-ref">Multi-thread decoding</span></a>
brings some tips.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>The decoder must be a function,</strong> i.e., given a chromosome, it must output
the same solution/fitness in any call. In other words, the decoder must be a
deterministic (or, at most, pseudo-random) procedure.</p>
</div>
<p>Indeed, this is an essential aspect of the decoder: <strong>it must produce the exact
solution for the same chromosome.</strong> If the decoder cannot do it, we will see a
substantial degradation in the BRKGA performance regarding convergence. BRKGA
cannot learn well with non-deterministic decoders. Moreover, non-deterministic
decoders do not allow reproducibility, impairing their utility for production
and academic environments.</p>
<p>However, there are several situations where we must toss a coin to break a tie.
In this case, we must guarantee that such a coin always results in the same
sequence of values for a given chromosome. In other words, we must ensure that
our decoder is pseudo-random or pseudo-non-deterministic. We could create a
Random Number Generator (RNG) inside each decoding call with a fixed seed. But
this strategy may not explorer the solution space as needed since the seed is
the same for all decoding.</p>
<p>We can use several strategies to mitigate such situations, but the most used is
to create an (n+1)-sized chromosome such that one allele (in general, the first
or the last) is used as a seed to the RNG. In this way, the chromosome also
carries the information for breaking ties, and therefore, we can reproduce the
solution. This is an example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="o">::</span><span class="n">result_type</span> <span class="n">seed_t</span><span class="p">;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="c1">// This just reinterprets the bits as they are. This is the safest way to</span>
<span class="linenos"> 4</span><span class="c1">// guarantee reproducibility since we only use the bits. However, since we</span>
<span class="linenos"> 5</span><span class="c1">// are converting the range [0.0, 1.0] from a double, we may have a skewed</span>
<span class="linenos"> 6</span><span class="c1">// list of seeds. We are missing the integer part and negative numbers bits.</span>
<span class="linenos"> 7</span><span class="c1">// Still, for most applications, this should be good enough.</span>
<span class="linenos"> 8</span><span class="k">auto</span> <span class="n">seed1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">seed_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">chromosome</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="c1">// This version may grab all the seed&#39;s domain. However, we may face</span>
<span class="linenos">11</span><span class="c1">// numerical issues with precision here. In some cases, the same double may</span>
<span class="linenos">12</span><span class="c1">// generate two different seeds (depending on the platform), and we will</span>
<span class="linenos">13</span><span class="c1">// lose reproducibility. We only recommend using this if you really need a</span>
<span class="linenos">14</span><span class="c1">// very diverse set of seeds to generate millions of random numbers in the</span>
<span class="linenos">15</span><span class="c1">// decoder.</span>
<span class="linenos">16</span><span class="k">auto</span> <span class="n">seed2</span> <span class="o">=</span> <span class="n">seed_t</span><span class="p">(</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">seed_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">chromosome</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="c1">// Just instantiate a local random number generator. Tip: this can hit your</span>
<span class="linenos">19</span><span class="c1">// performance. Better allocate the RNG before. If you use multiple threads,</span>
<span class="linenos">20</span><span class="c1">// please read the Section :ref:`Multi-thread decoding &lt;doxid-guide_guide_tips_multi_thread_decoding&gt;`.</span>
<span class="linenos">21</span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">my_local_rng</span><span class="p">(</span><span class="n">seed1</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="building-brkga-mp-ipr-algorithm-object">
<span id="doxid-guide-brkga-object"></span><h2>Building BRKGA-MP-IPR algorithm object<a class="headerlink" href="#building-brkga-mp-ipr-algorithm-object" title="Link to this heading"></a></h2>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code> is the main object that
implements all BRKGA-MP-IPR algorithms such as evolution, path relink, and
other auxiliary procedures. Note that <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code> is a template
parametrized by the decoder type. This strategy avoids runtime polymorphism,
drastically improving the performance of the code.</p>
<p>The first step is to call the algorithm constructor that has the following
signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">BRKGA_MP_IPR</span><span class="p">(</span>
<span class="linenos">2</span>    <span class="n">Decoder</span><span class="o">&amp;</span> <span class="n">decoder_reference</span><span class="p">,</span>
<span class="linenos">3</span>    <span class="k">const</span> <span class="n">Sense</span> <span class="n">sense</span><span class="p">,</span>
<span class="linenos">4</span>    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">seed</span><span class="p">,</span>
<span class="linenos">5</span>    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">chromosome_size</span><span class="p">,</span>
<span class="linenos">6</span>    <span class="k">const</span> <span class="n">BrkgaParams</span><span class="o">&amp;</span> <span class="n">params</span><span class="p">,</span>
<span class="linenos">7</span>    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">max_threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="linenos">8</span>    <span class="k">const</span> <span class="kt">bool</span> <span class="n">evolutionary_mechanism_on</span> <span class="o">=</span> <span class="nb">true</span>
<span class="linenos">9</span><span class="p">);</span>
</pre></div>
</div>
<p>The first argument is the decoder object that must implement the <code class="docutils literal notranslate"><span class="pre">decode()</span></code>
method as discussed before. You also must indicate whether you are minimizing
or maximizing through parameter <code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_Sense.html#doxid-namespace-b-r-k-g-a-1af28538be111c8320b2fec44b77ec5e9b"><span class="std std-ref"><span class="pre">BRKGA::Sense</span></span></a></code>.</p>
<p>A good seed also must be provided for the (pseudo) random number generator
(according to <span id="id9">[<a class="reference internal" href="#id64" title="Makoto Matsumoto, Isaku Wada, Ai Kuramoto, and Hyo Ashihara. Common defects in initialization of pseudorandom number generators. ACM Trans. Model. Comput. Simul., 17(4):15–es, sep 2007. doi:10.1145/1276927.1276928.">MWKA07</a>]</span>).
BRKGA-MP-IPR uses the <a class="reference external" href="https://en.wikipedia.org/wiki/Mersenne_Twister">Mersenne Twister
engine</a>
from the
<a class="reference external" href="http://www.cplusplus.com/reference/random/mt19937">standard C++ library</a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">chromosome_size</span></code> also must be given. It indicates the length of each
chromosome in the population. In general, this size depends on the instance and
how the decoder works. The constructor also takes a <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> object that holds several
parameters. We will take about that later.</p>
<p><code class="docutils literal notranslate"><span class="pre">max_threads</span></code> defines how many threads the algorithm should use for decoding
and some other operations. As said before, <strong>you must guarantee that the
decoder is thread-safe</strong> when using two or more threads. See
<a class="reference internal" href="#doxid-guide-guide-tips-multi-thread-decoding"><span class="std std-ref">Multi-thread decoding</span></a>
for more information.</p>
<p>Another common argument is <code class="docutils literal notranslate"><span class="pre">evolutionary_mechanism_on</span></code> which is enabled by
default. When disabled, no evolution is performed. The algorithm only decodes
the chromosomes and ranks them. On each generation, all population is replaced
excluding the best chromosome. This flag helps on implementations of simple
multi-start algorithms.</p>
<p>All BRKGA and Path Relink hyper-parameters are stored in a
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code> object.
Such objects can be read and write from plain text files or can be created by
hand by the user. There is also a companion
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">BRKGA::ControlParams</span></span></a></code>
object that stores extra control parameters that can be used outside the
BRKGA-MP-IPR to control several aspects of the optimization. For instance,
interval to apply path relink, reset the population, perform population
migration, among others. This is how a configuration file looks like (see
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/config.conf">config.conf</a>
for a commented version):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># BRKGA and IPR parameters</span>
<span class="linenos"> 2</span><span class="n">population_size</span> <span class="mi">2000</span>
<span class="linenos"> 3</span><span class="n">elite_percentage</span> <span class="mf">0.30</span>
<span class="linenos"> 4</span><span class="n">mutants_percentage</span> <span class="mf">0.15</span>
<span class="linenos"> 5</span><span class="n">num_elite_parents</span> <span class="mi">2</span>
<span class="linenos"> 6</span><span class="n">total_parents</span> <span class="mi">3</span>
<span class="linenos"> 7</span><span class="n">bias_type</span> <span class="n">LOGINVERSE</span>
<span class="linenos"> 8</span><span class="n">num_independent_populations</span> <span class="mi">3</span>
<span class="linenos"> 9</span><span class="n">pr_number_pairs</span> <span class="mi">0</span>
<span class="linenos">10</span><span class="n">pr_minimum_distance</span> <span class="mf">0.15</span>
<span class="linenos">11</span><span class="n">pr_type</span> <span class="n">DIRECT</span>
<span class="linenos">12</span><span class="n">pr_selection</span> <span class="n">BESTSOLUTION</span>
<span class="linenos">13</span><span class="n">pr_distance_function_type</span> <span class="n">KENDALLTAU</span>
<span class="linenos">14</span><span class="n">alpha_block_size</span> <span class="mf">1.0</span>
<span class="linenos">15</span><span class="n">pr_percentage</span> <span class="mf">1.0</span>
<span class="linenos">16</span><span class="n">num_exchange_individuals</span> <span class="mi">1</span>
<span class="linenos">17</span><span class="n">shaking_type</span> <span class="n">SWAP</span>
<span class="linenos">18</span><span class="n">shaking_intensity_lower_bound</span> <span class="mf">0.25</span>
<span class="linenos">19</span><span class="n">shaking_intensity_upper_bound</span> <span class="mf">0.75</span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="c1"># Control parameters</span>
<span class="linenos">22</span><span class="n">maximum_running_time</span> <span class="mi">60</span>
<span class="linenos">23</span><span class="n">exchange_interval</span> <span class="mi">100</span>
<span class="linenos">24</span><span class="n">ipr_interval</span> <span class="mi">200</span>
<span class="linenos">25</span><span class="n">shake_interval</span> <span class="mi">300</span>
<span class="linenos">26</span><span class="n">reset_interval</span> <span class="mi">500</span>
<span class="linenos">27</span><span class="n">stall_offset</span> <span class="mi">100</span>
</pre></div>
</div>
<p>To read this file, you can use the function
<code class="docutils literal notranslate"><a class="reference internal" href="group_brkga_control_params.html#doxid-group-brkga-control-params-1ga1c8b456ad75a3b522d315d4167546ae6"><span class="std std-ref"><span class="pre">BRKGA::readConfiguration()</span></span></a></code>
which returns a
<code class="docutils literal notranslate"><a class="reference external" href="https://en.cppreference.com/w/cpp/utility/pair"><span class="pre">std::pair</span></a><span class="pre">&lt;</span><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BrkgaParams</span></span></a><span class="pre">,</span> <a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">ControlParams</span></span></a><span class="pre">&gt;</span></code>.
When reading such
file, the function ignores all blank lines, and lines starting with <code class="docutils literal notranslate"><span class="pre">#</span></code>. As
commented before,
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code>
contains all hyper-parameters regarding BRKGA and IPR methods and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">BRKGA::ControlParams</span></span></a></code>
contains extra control parameters, and they are not mandatory to
the BRKGA-MP-IPR itself.</p>
<p>Let’s take a look in the example from
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/main_minimal.cpp">main_minimal.cpp</a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="linenos"> 2</span><span class="k">const</span> <span class="n">string</span> <span class="n">config_file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="linenos"> 3</span><span class="k">const</span> <span class="n">string</span> <span class="n">instance_file</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="linenos"> 4</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="k">auto</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">TSP_Instance</span><span class="p">(</span><span class="n">instance_file</span><span class="p">);</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="k">auto</span> <span class="p">[</span><span class="n">brkga_params</span><span class="p">,</span> <span class="n">control_params</span><span class="p">]</span> <span class="o">=</span>
<span class="linenos"> 9</span>    <span class="n">BRKGA</span><span class="o">::</span><span class="n">readConfiguration</span><span class="p">(</span><span class="n">config_file</span><span class="p">);</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="n">control_params</span><span class="p">.</span><span class="n">maximum_running_time</span> <span class="o">=</span> <span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span> <span class="p">{</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">])};</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="n">TSP_Decoder</span> <span class="nf">decoder</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">BRKGA_MP_IPR</span><span class="o">&lt;</span><span class="n">TSP_Decoder</span><span class="o">&gt;</span> <span class="n">algorithm</span><span class="p">(</span>
<span class="linenos">16</span>    <span class="n">decoder</span><span class="p">,</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">Sense</span><span class="o">::</span><span class="n">MINIMIZE</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span>
<span class="linenos">17</span>    <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">,</span> <span class="n">num_threads</span>
<span class="linenos">18</span><span class="p">);</span>
</pre></div>
</div>
<p>This code gets some arguments from the command line and loads a TSP instance.
After that, it reads the BRKGA parameters from the configuration file.
Here, instead of using the maximum time given in the config file, we overwrite
it with the maximum time passed by the user through the command line. We then
build the decoder object, and the BRKGA algorithm. Since we are looking for
cycles of minimum cost, we ask for the algorithm <code class="docutils literal notranslate"><span class="pre">MINIMIZE</span></code>. The starting
seed is also given. Since <code class="docutils literal notranslate"><span class="pre">TSP_Decode</span></code> considers each chromosome key as a
node/city, the length of the chromosome must be the number of nodes, i.e.,
<code class="docutils literal notranslate"><span class="pre">instance.num_nodes</span></code>. Finally, we also pass the BRKGA parameters.</p>
<p>Now, we have a
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code>
algorithm/object which will be used to call all other functions during the
optimization. Note that we can build several
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR</span></span></a></code>
objects using different parameters, decoders, or instance data. These
structures can be evolved in parallel and mixed-and-matched at your will. Each
one holds a self-contained BRKGA state including populations, fitness
information, and a state of the random number generator.</p>
</section>
<section id="it-s-optimization-time">
<span id="doxid-guide-opt"></span><h2>It’s optimization time<a class="headerlink" href="#it-s-optimization-time" title="Link to this heading"></a></h2>
<p>Until version 2.0, the user was responsible for creating the main optimization
loop. While this strategy gives fine control over the algorithm’s flow, he/she
must call the BRKGA-MP-IPR features, such as IPR, shaking, population reset,
and others, individually. That generates cumbersome code, which usually takes a
lot of time for the developer to make it right.</p>
<p>In version 3.0, we abstract all these details, creating a single method
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::run()</span></span></a></code>
containing the complete optimization loop, which may use all the features
provided by this library. In this way, we provide a comprehensive and
easy-to-use single-entry point, like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="k">auto</span> <span class="n">final_status</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">control_params</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cout</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">run()</span></span></a></code>
takes a <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">BRKGA::ControlParams</span></span></a></code>
object which contains several control parameters in how the main loop behaves.
It is through these control parameters that the user can control the maximum
optimization time and when features like IPR, shaking, etc, are called.
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">run()</span></span></a></code>
also takes an output stream to log some information along the
optimization.</p>
<p>Once done,
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">run()</span></span></a></code>
returns a
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_AlgorithmStatus.html#doxid-class-b-r-k-g-a-1-1-algorithm-status"><span class="std std-ref"><span class="pre">BRKGA::AlgorithmStatus</span></span></a></code>
object that brings all the details about the
optimization itself, such as the number of iterations, running time, number of
calls for each method, and others. Most importantly,
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_AlgorithmStatus.html#doxid-class-b-r-k-g-a-1-1-algorithm-status"><span class="std std-ref"><span class="pre">AlgorithmStatus</span></span></a></code>
also brings the fitness and the chromosome, representing the best solution
found during the optimization (note that it is not the best chromosome in the
current population because it may be fully reset and has lost the best
solution).</p>
<p>The main loop should be like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">must_stop</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 2</span>    <span class="n">evolve</span><span class="p">();</span> <span class="c1">// One generation.</span>
<span class="linenos"> 3</span>    <span class="k">if</span><span class="p">(</span><span class="n">best</span> <span class="n">solution</span> <span class="n">improvement</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 4</span>        <span class="n">Save</span> <span class="n">best</span> <span class="n">solution</span><span class="p">;</span>
<span class="linenos"> 5</span>        <span class="n">Call</span> <span class="n">observer</span> <span class="n">callbacks</span><span class="p">;</span>
<span class="linenos"> 6</span>    <span class="p">}</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">must_stop</span> <span class="o">&amp;&amp;</span> <span class="n">ipr_interval</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stalled_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
<span class="linenos"> 9</span>       <span class="n">stalled_iterations</span> <span class="o">%</span> <span class="n">ipr_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">10</span>         <span class="n">pathRelink</span><span class="p">();</span>
<span class="linenos">11</span>         <span class="k">if</span><span class="p">(</span><span class="n">best</span> <span class="n">solution</span> <span class="n">improvement</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">12</span>             <span class="n">Save</span> <span class="n">best</span> <span class="n">solution</span><span class="p">;</span>
<span class="linenos">13</span>             <span class="n">Call</span> <span class="n">observer</span> <span class="n">callbacks</span><span class="p">;</span>
<span class="linenos">14</span>         <span class="p">}</span>
<span class="linenos">15</span>     <span class="p">}</span>
<span class="linenos">16</span>
<span class="linenos">17</span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">must_stop</span> <span class="o">&amp;&amp;</span> <span class="n">exchange_interval</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stalled_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
<span class="linenos">18</span>       <span class="n">stalled_iterations</span> <span class="o">%</span> <span class="n">exchange_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">19</span>         <span class="n">exchangeElite</span><span class="p">();</span>
<span class="linenos">20</span>    <span class="p">}</span>
<span class="linenos">21</span>
<span class="linenos">22</span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">must_stop</span> <span class="o">&amp;&amp;</span> <span class="n">shake_interval</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stalled_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
<span class="linenos">23</span>       <span class="n">stalled_iterations</span> <span class="o">%</span> <span class="n">shake_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">24</span>         <span class="n">shake</span><span class="p">();</span>
<span class="linenos">25</span>    <span class="p">}</span>
<span class="linenos">26</span>
<span class="linenos">27</span>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">must_stop</span> <span class="o">&amp;&amp;</span> <span class="n">reset_interval</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">stalled_iterations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
<span class="linenos">28</span>       <span class="n">stalled_iterations</span> <span class="o">%</span> <span class="n">reset_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">29</span>         <span class="n">reset</span><span class="p">();</span>
<span class="linenos">30</span>    <span class="p">}</span>
<span class="linenos">31</span><span class="p">}</span>
</pre></div>
</div>
<p>Therefore, note that the order that
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aa8da5193248d23ced19e68483aca31a5"><span class="std std-ref"><span class="pre">pathRelink()</span></span></a></code>,
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1ab89298e6c633a81bf8c0462fb40ddd15"><span class="std std-ref"><span class="pre">exchangeElite()</span></span></a></code>,
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a3721a91ed9d3fcbdc57fbcee2e20ac66"><span class="std std-ref"><span class="pre">shake()</span></span></a></code>,
and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a3bfe66221dd2f9c755a65ed7df14e350"><span class="std std-ref"><span class="pre">reset()</span></span></a></code>
are called, depends on the thresholds defined in
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">ControlParams</span></span></a></code>.</p>
<p>For path relinking, the block size is computed by
<span class="math notranslate nohighlight">\(\lceil \alpha \times \sqrt{p} \rceil\)</span> where
<span class="math notranslate nohighlight">\(\alpha\)</span> is
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params-1a40ff7da597d2c4eadabf3f62b3b9196d"><span class="std std-ref"><span class="pre">BrkgaParams::alpha_block_size</span></span></a></code>
and <span class="math notranslate nohighlight">\(p\)</span> is
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params-1a8a4b0592480f32a3cf186b6d1759f571"><span class="std std-ref"><span class="pre">BrkgaParams::population_size</span></span></a></code>.
If the size is larger than the chromosome size, the size is set to half of the
chromosome size. For more details on that, refer to
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aa8da5193248d23ced19e68483aca31a5"><span class="std std-ref"><span class="pre">pathRelink()</span></span></a></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The algorithm always test against maximum running time and for the maximum
stalled iterations/generations given by
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">ControlParams</span></span></a></code>
indenpendently of the stopping criteria function supplied by the user. This
is especially important when activating the implicit path reliking which is
<strong>very timing consuming</strong>. If you are using IPR, we <strong>STRONGLY RECOMMEND TO
SET A MAXIMUM TIME</strong> since this is the core stopping criteria on IPR.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The decoding is done in parallel using threads, and the user <strong>must
guarantee that the decoder is THREAD-SAFE.</strong> If such property cannot be
held, we suggest using a single thread for optimization.</p>
</div>
<section id="options-before-optimization-starts">
<span id="doxid-guide-before-opt"></span><h3>Options before optimization starts<a class="headerlink" href="#options-before-optimization-starts" title="Link to this heading"></a></h3>
<p>While we can call
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">run()</span></span></a></code>
right away, some options can enhance the pipeline before running the
optimization. We can:</p>
<ul class="simple">
<li><p>Set solution observer callbacks that are called when the best solution is
updated;</p></li>
<li><p>Set a custom stopping-criteria function other than solely time and stalled
iterations;</p></li>
<li><p>Set a custom shake procedure instead of using the canonical BRKGA-MP-IPR
shaking options;</p></li>
<li><p>Set custom bias function for chromosome ranking;</p></li>
<li><p>Provide warmstart solutions to the algorithm to improve general solution
quality and convergence.</p></li>
</ul>
<p>We will explore such options in the following sections.</p>
<section id="setting-solution-observers-callbacks">
<span id="doxid-guide-setting-observer-callbacks"></span><h4>Setting solution observers / callbacks<a class="headerlink" href="#setting-solution-observers-callbacks" title="Link to this heading"></a></h4>
<p>Usually, tracking the algorithm’s convergence is a good idea.
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">run()</span></span></a></code>
provides a callback mechanism activated when the best solution found so far
during the optimization is improved. This is done by calling functions provided
by the user. For instance:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">algorithm</span><span class="p">.</span><span class="n">addNewSolutionObserver</span><span class="p">(</span>
<span class="linenos"> 2</span>    <span class="p">[](</span><span class="k">const</span> <span class="n">AlgorithmStatus</span><span class="o">&amp;</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 3</span>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span>
<span class="linenos"> 4</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt; Iter: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">status</span><span class="p">.</span><span class="n">current_iteration</span>
<span class="linenos"> 5</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot; | solution: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">status</span><span class="p">.</span><span class="n">best_fitness</span>
<span class="linenos"> 6</span>        <span class="o">&lt;&lt;</span> <span class="s">&quot; | time: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">status</span><span class="p">.</span><span class="n">current_time</span>
<span class="linenos"> 7</span>        <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 8</span>        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Dont&#39; stop the optimization.</span>
<span class="linenos"> 9</span>     <span class="p">}</span>
<span class="linenos">10</span><span class="p">);</span>
</pre></div>
</div>
<p>adds a callback function that prints the current iteration, the value of the
current best solution, and the time it was found. In this example, we use a
lambda function. Obviously, you can define a named function outside this scope
and add it as a callback, too.</p>
<p>You have noted that we use the method
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aa6cf3aca1879ffd4dc0c986340163254"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::addNewSolutionObserver()</span></span></a></code>
to add the callback function which must have the following signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">observer_callback_name</span><span class="p">(</span><span class="k">const</span> <span class="n">AlgorithmStatus</span><span class="o">&amp;</span> <span class="n">status</span><span class="p">);</span>
</pre></div>
</div>
<p>where
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_AlgorithmStatus.html#doxid-class-b-r-k-g-a-1-1-algorithm-status"><span class="std std-ref"><span class="pre">BRKGA::AlgorithmStatus</span></span></a></code>
provides the current optimization status, such as current
time, number of iterations, best solution values, best chromosome, and many
other statistics. Indeed,
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_AlgorithmStatus.html#doxid-class-b-r-k-g-a-1-1-algorithm-status"><span class="std std-ref"><span class="pre">BRKGA::AlgorithmStatus</span></span></a></code>
is the primary way to track the algorithm’s convergence. Then, this function
returns a <code class="docutils literal notranslate"><span class="pre">boolean</span></code> that, if <code class="docutils literal notranslate"><span class="pre">true</span></code>, aborts the optimization immediately.
This is useful when one wants only to obtain a solution with a particular value
or characteristic and stop to save time.</p>
<p>You can add as many observers as you want. They will be called in the order
they are added.</p>
<p>One interesting usage of such callbacks is to perform (expensive) local search
from the best solution when this cannot be done during the decoder process.
Once the local search is done, we can inject the improved solution/chromosome
back into the population using method
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a0347f67b59bfe36856d1c27c95d4b151"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::injectChromosome()</span></span></a></code>.
Please, see section
<a class="reference internal" href="#doxid-guide-inject-chromosome"><span class="std std-ref">Injecting solutions / chromosome into the population</span></a>
for more details.</p>
</section>
<section id="defining-custom-stopping-criteria">
<span id="doxid-guide-setting-stopping-criteria"></span><h4>Defining custom stopping criteria<a class="headerlink" href="#defining-custom-stopping-criteria" title="Link to this heading"></a></h4>
<p>By default, the algorithm always test for <strong>the maximum running time</strong> and for
<strong>the maximum stalled iterations/generations</strong> given by
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">ControlParams</span></span></a></code>.
However, in some situations, the user may want to evaluate additional criteria
to determine whether the optimization must stop or not. For example, in a
minimization problem, we may want to stop the value within a distance from a
lower bound or when we reach a given number of iterations, as shown below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">fitness_t</span> <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">compute_lower_bound</span><span class="p">();</span>
<span class="linenos"> 2</span><span class="kt">unsigned</span> <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="n">algorithm</span><span class="p">.</span><span class="n">setStoppingCriteria</span><span class="p">(</span>
<span class="linenos"> 5</span>    <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">AlgorithmStatus</span><span class="o">&amp;</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 6</span>        <span class="k">return</span>
<span class="linenos"> 7</span>            <span class="n">status</span><span class="p">.</span><span class="n">best_fitness</span> <span class="o">&lt;=</span> <span class="n">lower_bound</span> <span class="o">*</span> <span class="mf">1.1</span><span class="p">;</span> <span class="c1">// 10% from the lower bound</span>
<span class="linenos"> 8</span>            <span class="o">||</span>
<span class="linenos"> 9</span>            <span class="n">status</span><span class="p">.</span><span class="n">current_iteration</span> <span class="o">==</span> <span class="n">max_iterations</span><span class="p">;</span>
<span class="linenos">10</span>    <span class="p">}</span>
<span class="linenos">11</span><span class="p">);</span>
</pre></div>
</div>
<p>For that, we use the method
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1adee8fc8410a56e71b2af84ed6f4f2a7c"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::setStoppingCriteria()</span></span></a></code>
which takes a function with the signature</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">stopping_callback_name</span><span class="p">(</span><span class="k">const</span> <span class="n">AlgorithmStatus</span><span class="o">&amp;</span> <span class="n">status</span><span class="p">);</span>
</pre></div>
</div>
<p>Similar to observer callbacks, the function must take a reference to a
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_AlgorithmStatus.html#doxid-class-b-r-k-g-a-1-1-algorithm-status"><span class="std std-ref"><span class="pre">BRKGA::AlgorithmStatus</span></span></a></code>
object and return <code class="docutils literal notranslate"><span class="pre">true</span></code> when the optimization must stop or <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you are using implicit path relinking (IPR), which is <strong>very timing
consuming</strong>, we <strong>STRONGLY RECOMMEND TO SET A MAXIMUM TIME</strong> since this is
the core stopping criteria on IPR.</p>
</div>
<p>If you really mean to have no maximum time and/or maximum stalled iterations
set, we recommend to use the following code:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1">// After reading your parameters, e.g.,</span>
<span class="linenos">2</span><span class="c1">// auto [brkga_params, control_params] = readConfiguration(&quot;config.conf&quot;);</span>
<span class="linenos">3</span>
<span class="linenos">4</span><span class="c1">// You can set the time to max...</span>
<span class="linenos">5</span><span class="n">control_params</span><span class="p">.</span><span class="n">maximum_running_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="o">::</span><span class="n">max</span><span class="p">();</span>
<span class="linenos">6</span>
<span class="linenos">7</span><span class="c1">// ... and/or the stalled iterations to max.</span>
<span class="linenos">8</span><span class="n">control_params</span><span class="p">.</span><span class="n">stall_offset</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="providing-custom-shake-procedure">
<span id="doxid-guide-providing-custom-shake"></span><h4>Providing custom shake procedure<a class="headerlink" href="#providing-custom-shake-procedure" title="Link to this heading"></a></h4>
<p>BRKGA-MP-IPR supplies two canonical ways to perturb the population called
shaking procedures (<a class="reference internal" href="#doxid-guide-guide-shaking"><span class="std std-ref">more details here</span></a>).
Shaking was introduced by <span id="id10">[<a class="reference internal" href="#id37" title="Carlos E. Andrade, Thuener Silva, and Luciana S. Pessoa. Minimizing flowtime in a flowshop scheduling problem with a biased random-key genetic algorithm. Expert Systems with Applications, 128:67–80, Aug 2019. doi:10.1016/j.eswa.2019.03.007.">ASP19</a>]</span>, and the
canonical shaking procedures are effective in most cases. However, there are
situation that calls for a custom (maybe more effective) procedure (e.g.,
<span id="id11">[<a class="reference internal" href="#id65" title="William Higino, Antônio Augusto Chaves, and Vinicius Veloso de Melo. Biased random-key genetic algorithm applied to the vehicle routing problem with private fleet and common carrier. 2018 IEEE Congress on Evolutionary Computation (CEC), pages 1–8, 2018. doi:10.1109/CEC.2018.8477905.">HCdM18</a>]</span>). In such cases, one can use method</p>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a4b5019c33a563d1906f0b7d0a8304169"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::setShakingMethod()</span></span></a></code>
which sets a shaking function with the signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kt">void</span> <span class="nf">custom_shaking</span><span class="p">(</span>
<span class="linenos">2</span>    <span class="kt">double</span> <span class="n">lower_bound</span><span class="p">,</span>
<span class="linenos">3</span>    <span class="kt">double</span> <span class="n">upper_bound</span><span class="p">,</span>
<span class="linenos">4</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Population</span><span class="o">&gt;&gt;&amp;</span> <span class="n">populations</span><span class="p">,</span>
<span class="linenos">5</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;&gt;&amp;</span> <span class="n">shaken</span>
<span class="linenos">6</span><span class="p">);</span>
</pre></div>
</div>
<p>We have that:</p>
<ul class="simple">
<li><p>Parameters <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_bound</span></code> is the shaking intensity
bounds to be applied. Usually, the define a range where the intensity is
sampled;</p></li>
<li><p>Parameter <code class="docutils literal notranslate"><span class="pre">populations</span></code> are the current BRKGA populations;</p></li>
<li><p>Parameter <code class="docutils literal notranslate"><span class="pre">shaken</span></code> is a list of <code class="docutils literal notranslate"><span class="pre">&lt;population</span> <span class="pre">index,</span> <span class="pre">chromosome</span> <span class="pre">index&gt;</span></code>
pairs indicating which chromosomes were shaken on which population,
so that they got re-decoded.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">shaken</span></code> is empty, all chromosomes of all populations are
re-decoded. This may be slow. Even if you intention is to do so,
it is faster to populate <code class="docutils literal notranslate"><span class="pre">shaken</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This procedure can be <strong>very intrusive</strong> since it must manipulate
the population. So, the user must make sure that BRKGA invariants
are kept, such as chromosome size and population size.
Otherwise, the overall functionaly may be compromised.</p>
</div>
<p>In the example below, we implement the standard mutation for vanilla
genetic algorithms to the elite population. Note that we kept the random number
generator outside, to make sure we generate different sequences on each call:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// A random number generator.</span>
<span class="linenos"> 2</span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng</span><span class="p">(</span><span class="mi">2700001</span><span class="p">);</span>
<span class="linenos"> 3</span><span class="n">rng</span><span class="p">.</span><span class="n">discard</span><span class="p">(</span><span class="n">rng</span><span class="p">.</span><span class="n">state_size</span><span class="p">);</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="c1">// Determines whether we change the allele or not.</span>
<span class="linenos"> 6</span><span class="n">std</span><span class="o">::</span><span class="n">bernoulli_distribution</span> <span class="n">must_change</span><span class="p">(</span><span class="mf">0.50</span><span class="p">);</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">setShakingMethod</span><span class="p">(</span>
<span class="linenos"> 9</span>     <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">double</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="kt">double</span> <span class="n">upper_bound</span><span class="p">,</span>
<span class="linenos">10</span>         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Population</span><span class="o">&gt;&gt;&amp;</span> <span class="n">populations</span><span class="p">,</span>
<span class="linenos">11</span>         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;&gt;&amp;</span> <span class="n">shaken</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">12</span>
<span class="linenos">13</span>         <span class="c1">// Determines the value of the allele.</span>
<span class="linenos">14</span>         <span class="n">std</span><span class="o">::</span><span class="n">uniform_real_distribution</span><span class="o">&lt;&gt;</span> <span class="n">allele_value</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">);</span>
<span class="linenos">15</span>
<span class="linenos">16</span>         <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">pop_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pop_idx</span> <span class="o">&lt;</span> <span class="n">populations</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">pop_idx</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">17</span>             <span class="k">auto</span><span class="o">&amp;</span> <span class="n">population</span> <span class="o">=</span> <span class="n">populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">population</span><span class="p">;</span>
<span class="linenos">18</span>
<span class="linenos">19</span>             <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">chr_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chr_idx</span> <span class="o">&lt;</span> <span class="n">population</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">chr_idx</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">20</span>                 <span class="k">auto</span><span class="o">&amp;</span> <span class="n">chromosome</span> <span class="o">=</span> <span class="n">population</span><span class="p">[</span><span class="n">chr_idx</span><span class="p">];</span>
<span class="linenos">21</span>
<span class="linenos">22</span>                 <span class="kt">bool</span> <span class="n">change</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="linenos">23</span>                 <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chromosome</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">24</span>                     <span class="k">if</span><span class="p">(</span><span class="n">must_change</span><span class="p">(</span><span class="n">rng</span><span class="p">))</span> <span class="p">{</span>
<span class="linenos">25</span>                         <span class="n">chromosome</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">allele_value</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
<span class="linenos">26</span>                         <span class="n">change</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="linenos">27</span>                     <span class="p">}</span>
<span class="linenos">28</span>                 <span class="p">}</span>
<span class="linenos">29</span>
<span class="linenos">30</span>                 <span class="k">if</span><span class="p">(</span><span class="n">change</span><span class="p">)</span>
<span class="linenos">31</span>                     <span class="n">shaken</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">pop_idx</span><span class="p">,</span> <span class="n">chr_idx</span><span class="p">});</span>
<span class="linenos">32</span>             <span class="p">}</span> <span class="c1">// chr for</span>
<span class="linenos">33</span>         <span class="p">}</span> <span class="c1">// pop for</span>
<span class="linenos">34</span>     <span class="p">};</span> <span class="c1">// lambda</span>
<span class="linenos">35</span> <span class="p">);</span> <span class="c1">// setShakingMethod</span>
</pre></div>
</div>
</section>
<section id="setting-custom-bias-function">
<span id="doxid-guide-setting-custom-bias-function"></span><h4>Setting custom bias function<a class="headerlink" href="#setting-custom-bias-function" title="Link to this heading"></a></h4>
<p>The bias function controls how alleles are chosen from the (multi) parents
during mating. While BRKGA-MP-IPR framework already provides an extensive set
of functions through
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_BiasFunctionType.html#doxid-namespace-b-r-k-g-a-1af0ede0f2a7123e654a4e3176b5539fb1"><span class="std std-ref"><span class="pre">BRKGA::BiasFunctionType</span></span></a></code>,
one may want to change that behavior using a
custom function (e.g., to
<a class="reference internal" href="#doxid-guide-guide-standard-brkga"><span class="std std-ref">simulate the vanilla BRKGA</span></a>).
This is done using method
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a8616c89626ca3c8e8d3b5adb1da24c92"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::setBiasCustomFunction()</span></span></a></code>,
where the user supplies the desired <strong>positive non-increasing function</strong> with
the signature</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="nf">bias_function</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">r</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The bias function must be a <strong>positive non-increasing function</strong>, i.e.
<span class="math notranslate nohighlight">\(f: \mathbb{N}^+ \to \mathbb{R}^+\)</span> such that <span class="math notranslate nohighlight">\(f(i) \ge 0\)</span> and
<span class="math notranslate nohighlight">\(f(i) \ge f(i+1)\)</span> for <span class="math notranslate nohighlight">\(i \in [1, \ldots, total\_parents]\)</span>.
This is requirement to produce the right probabilities.</p>
</div>
<p>Note that
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a8616c89626ca3c8e8d3b5adb1da24c92"><span class="std std-ref"><span class="pre">setBiasCustomFunction()</span></span></a></code>
tests the function and throw a
<a class="reference external" href="https://en.cppreference.com/w/cpp/error/runtime_error">std::runtime_error</a>
in case the funtion is not positive non-increasing.</p>
<p>For instance, the code below sets the inverse quadratic function as bias:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">algorithm</span><span class="p">.</span><span class="n">setBiasCustomFunction</span><span class="p">(</span>
<span class="linenos">2</span>    <span class="p">[](</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">3</span>        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
<span class="linenos">4</span>    <span class="p">}</span>
<span class="linenos">5</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="injecting-warm-start-solutions">
<span id="doxid-guide-injecting-warm-start-solutions"></span><h4>Injecting warm-start solutions<a class="headerlink" href="#injecting-warm-start-solutions" title="Link to this heading"></a></h4>
<p>One good strategy is to bootstrap the main optimization algorithm with good
solutions from fast heuristics
(<span id="id12">[<a class="reference internal" href="#id40" title="Mauro C. Lopes, Carlos E. Andrade, Thiago A. Queiroz, Mauricio G. C. Resende, and Flávio K. Miyazawa. Heuristics for a hub location-routing problem. Networks, 68(1):54-90, 2016. doi:10.1002/net.21685.">LAQ+16</a>]</span>,
<span id="id13">[<a class="reference internal" href="#id38" title="Luciana S. Pessoa and Carlos E. Andrade. Heuristics for a flowshop scheduling problem with stepwise job objective function. European Journal of Operational Research, 266(3):950–962, 2018. doi:10.1016/j.ejor.2017.10.045.">PA18</a>]</span>,
<span id="id14">[<a class="reference internal" href="#id37" title="Carlos E. Andrade, Thuener Silva, and Luciana S. Pessoa. Minimizing flowtime in a flowshop scheduling problem with a biased random-key genetic algorithm. Expert Systems with Applications, 128:67–80, Aug 2019. doi:10.1016/j.eswa.2019.03.007.">ASP19</a>]</span>)
or even from relaxations of integer linear programming models
<span id="id15">[<a class="reference internal" href="#id41" title="Carlos E. Andrade, Rodrigo F. Toso, Mauricio G. C. Resende, and Flávio K. Miyazawa. Biased random-key genetic algorithms for the winner determination problem in combinatorial auctions. Evolutionary Computation, 23:279–307, 2015. doi:10.1162/EVCO_a_00138.">ATRM15</a>]</span>
or constraint programming models
<span id="id16">[<a class="reference internal" href="#id31" title="Carlos E. Andrade, Lucia S. Pessoa, and Slawomir Stawiarski. The physical cell identity assignment problem: a practical optimization approach. IEEE Transactions on Evolutionary Computation, ():1–1, 2022. To appear. doi:10.1109/TEVC.2022.3185927.">APS22</a>]</span>.</p>
<p>Since BRKGA-MP-IPR does not know the problem structure, you must <em>encode</em> the
warm-start solution as chromosomes (vectors in the interval [0, 1)). In other
words, you must do the inverse process that your decoder does. For instance,
this is a piece of code from <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/main_complete.cpp">main_complete.cpp</a>
showing this process:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">auto</span> <span class="n">initial_solution</span> <span class="o">=</span> <span class="n">greedy_tour</span><span class="p">(</span><span class="n">instance</span><span class="p">);</span>
<span class="linenos"> 2</span><span class="c1">//...</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span>
<span class="linenos"> 5</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">keys</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">);</span> <span class="c1">// It should be == chromosome_size.</span>
<span class="linenos"> 6</span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">key</span> <span class="p">:</span> <span class="n">keys</span><span class="p">)</span>
<span class="linenos"> 7</span>    <span class="n">key</span> <span class="o">=</span> <span class="n">generate_canonical</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span>
<span class="linenos"> 8</span>                             <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">digits</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="n">sort</span><span class="p">(</span><span class="n">keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">keys</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">Chromosome</span> <span class="n">initial_chromosome</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">);</span>
<span class="linenos">13</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">initial_tour</span> <span class="o">=</span> <span class="n">initial_solution</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="linenos">14</span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">keys</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="linenos">15</span>    <span class="n">initial_chromosome</span><span class="p">[</span><span class="n">initial_tour</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="linenos">16</span>
<span class="linenos">17</span><span class="n">algorithm</span><span class="p">.</span><span class="n">setInitialPopulation</span><span class="p">(</span>
<span class="linenos">18</span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">Chromosome</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial_chromosome</span><span class="p">)</span>
<span class="linenos">19</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, we create one incumbent solution using the greedy heuristic <code class="docutils literal notranslate"><span class="pre">greedy_tour()</span></code>
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/tree/master/examples/tsp/src/single_obj/heuristics">found here</a>.
It gives us <code class="docutils literal notranslate"><span class="pre">initial_solution</span></code> which is a <code class="docutils literal notranslate"><span class="pre">std::pair&lt;double,</span> <span class="pre">std::vector&lt;unsigned&gt;&gt;</span></code>
containing the cost of the tour and the tour itself which is a sequence of
nodes to be visited. In the next lines, we encode <code class="docutils literal notranslate"><span class="pre">initial_solution</span></code>. First,
we create a vector of sorted random <code class="docutils literal notranslate"><span class="pre">keys</span></code>. For that, we create a new random
number generator <code class="docutils literal notranslate"><span class="pre">rng</span></code>, the vector <code class="docutils literal notranslate"><span class="pre">keys</span></code>, and fill up <code class="docutils literal notranslate"><span class="pre">keys</span></code> with random
numbers in the interval [0, 1), using C++ standard library function
<code class="docutils literal notranslate"><a class="reference external" href="https://en.cppreference.com/w/cpp/numeric/random/generate_canonical"><span class="pre">generate_canonical&lt;&gt;()</span></a></code>
Once we have the keys, we sort them as
<code class="docutils literal notranslate"><span class="pre">TSP_Decoder::decode()</span></code> does. We then create the <code class="docutils literal notranslate"><span class="pre">initial_chromosome</span></code>, and
fill it up with <code class="docutils literal notranslate"><span class="pre">keys</span></code> according to the nodes’ order in <code class="docutils literal notranslate"><span class="pre">initial_solution</span></code>.
Finally, we use
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a59b05650ede92f5e0107ab606ff6e8b7"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::setInitialPopulation()</span></span></a></code>
to assign the incumbent to the initial population. Note that we enclose the
initial solution inside a vector of chromosomes, since
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a59b05650ede92f5e0107ab606ff6e8b7"><span class="std std-ref"><span class="pre">setInitialPopulation()</span></span></a></code>
may take more than one starting solution. See its signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">setInitialPopulation</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Chromosome</span><span class="o">&gt;&amp;</span> <span class="n">chromosomes</span><span class="p">);</span>
</pre></div>
</div>
<p>Indeed, you can have as much warm-start solutions as you like, limited to the
size of the populations.</p>
</section>
</section>
</section>
<section id="diy-building-an-optimization-loop-for-fine-control">
<span id="doxid-guide-fine-optimization-control"></span><h2>DIY: building an optimization loop for fine control<a class="headerlink" href="#diy-building-an-optimization-loop-for-fine-control" title="Link to this heading"></a></h2>
<p>While version 3.0 greatly enhances how to utilize all BRKGA-MP-IPR features
transparently, one may want to change the algorithm’s flow. For instance, we
are developing a hyperheuristic using BRKGA, IPR, and VND so that each
algorithm is called when some condition happens. For that, we kept all public
interfaces from version 2.0 to version 3.0. The following sections describe
each one of these features in detail.</p>
<section id="evolving-the-population">
<span id="doxid-guide-evolving-population"></span><h3>Evolving the population<a class="headerlink" href="#evolving-the-population" title="Link to this heading"></a></h3>
<p>The core aspect of the BRKGA-MP-IPR is the genetic algorithm itself. The
evolution of each generation/iteration is performed by method
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aee1828c2ca506f18b896f1fc75ceafcb"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::evolve()</span></span></a></code>, which
takes the number of generations we must evolve. The call is pretty simple:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">num_generations</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aee1828c2ca506f18b896f1fc75ceafcb"><span class="std std-ref"><span class="pre">evolve()</span></span></a></code>
evolves all populations for <code class="docutils literal notranslate"><span class="pre">num_generations</span></code>. If <code class="docutils literal notranslate"><span class="pre">num_genertions</span></code> is
omitted, only one generation is evolved.</p>
<p>Note that
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">run()</span></span></a></code>
calls
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aee1828c2ca506f18b896f1fc75ceafcb"><span class="std std-ref"><span class="pre">evolve()</span></span></a></code>
for one generation evolution per iteration of the main loop. In a custom setting,
one may evolve several generations per main loop iteration, if it make sense
for that scenario.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aee1828c2ca506f18b896f1fc75ceafcb"><span class="std std-ref"><span class="pre">evolve()</span></span></a></code>
does not check the stopping criteria and only stops when the given
iterations are done. Therefore, we must be careful when evolving multiple
generations at once. Please, check Section
<a class="reference internal" href="#doxid-guide-complex-decoders-and-timing"><span class="std std-ref">Complex decoders and timing.</span></a></p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Again, the decoding of each chromosome is done in parallel if multi-thread
is enabled. Therefore, <strong>we must guarantee that the decoder is
THREAD-SAFE.</strong> If such property cannot be held, we suggest using a single
thread.</p>
</div>
</section>
<section id="accessing-solutions-chromosomes">
<span id="doxid-guide-access-solutions"></span><h3>Accessing solutions/chromosomes<a class="headerlink" href="#accessing-solutions-chromosomes" title="Link to this heading"></a></h3>
<p>BRKGA-MP-IPR offers several mechanisms to access a variety of data during
the optimization. Most common, we want to access the best chromosome of the
current population after some iterations. You can use the companion methods:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">BRKGA_MP_IPR</span><span class="o">::</span><span class="n">getBestFitness</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">const</span> <span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">BRKGA_MP_IPR</span><span class="o">::</span><span class="n">getBestChromosome</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a0499e65fbddae20a97b276504fe72e39"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::getBestFitness()</span></span></a></code>
returns the value/fitness of the best chromosome across all current populations.
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aa4b0396a4780fde3be8d284c535b600e"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::getBestChromosome()</span></span></a></code>
returns a <em>reference</em> of the best chromosome across all current populations.
You may want to extract an actual solution from such chromosome, i.e.,
to apply a decoding function that returns the actual solution instead only
its value.</p>
<p>You may have noticed that we insist on the term <strong>current population.</strong>
This is because all getting methods use the current chromosomes, i.e., the
population whose state can change after any procedure such as IPR, shaking, or
reset. Usually, IPR preserves the best solution when manipulating the
population. However, the shaking and reset procedures often perturb and/or
deconstruct the population. <em>Therefore, there is a big chance that we will lose
the best solution.</em></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>All the get methods return information (fitness and chromosome) from the
current population, not the best solution found overall. Only method
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1acb361f402797d3c09390f852326fc7b8"><span class="std std-ref"><span class="pre">run()</span></span></a></code>
keeps the best solution overall.</p>
</div>
<p>You may also want to get a reference of specific chromosome and its fitness
for a given population using
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1abfe4eccfd47a8eb88fc920e640f8513f"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::getChromosome()</span></span></a></code>
and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a9d6636a50f519bf0f1e85257282c6065"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::getFitness()</span></span></a></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">getChromosome</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">population_index</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="n">fitness_t</span> <span class="nf">getFitness</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">population_index</span><span class="p">,</span>
                     <span class="kt">unsigned</span> <span class="n">position</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>For example, you can get the 3rd best chromosome (and it fitness)
from the 2nd population using</p>
<pre class="highlight literal-block"><span></span><span class="n">third_best_chr</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">getChromosome</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">third_best_fitness</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">getFitness</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Just remember that C++ is zero-indexed. So, the first population index is 0
(zero), the second population index is 1 (one), and so forth. The same happens
for the chromosomes.</p>
</div>
</section>
<section id="injecting-solutions-chromosome-into-the-population">
<span id="doxid-guide-inject-chromosome"></span><h3>Injecting solutions / chromosome into the population<a class="headerlink" href="#injecting-solutions-chromosome-into-the-population" title="Link to this heading"></a></h3>
<p>Now, suppose you get such chromosome or chromosomes and apply a quick local
search procedure on them. It may be useful to reinsert such new solutions in
the BRKGA population for the next evolutionary cycles. You can do that using
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a0347f67b59bfe36856d1c27c95d4b151"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::injectChromosome()</span></span></a></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">injectChromosome</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">population_index</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">position</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Note that the chromosome is put in a specific position of a given population.
The new chromosome replaces the old one, and the decoder is triggered to
compute the new fitness. Once done, the population is re-sorted according to
the chromosomes’ fitness.</p>
<p>For example, assuming the <code class="docutils literal notranslate"><span class="pre">algorithm</span></code> is your
BRKGA-MP-IPR object and <code class="docutils literal notranslate"><span class="pre">brkga_params</span></code> is your <code class="docutils literal notranslate"><span class="pre">BrkgaParams</span></code> object, the
following code injects the random chromosome <code class="docutils literal notranslate"><span class="pre">keys</span></code> into the population #1 in
the last position (<code class="docutils literal notranslate"><span class="pre">population_size</span> <span class="pre">-</span> <span class="pre">1</span></code>), i.e., it will replace the worst
solution by a random one:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span>
<span class="linenos">2</span><span class="n">Chromosome</span> <span class="nf">keys</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">);</span>
<span class="linenos">3</span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">key</span> <span class="p">:</span> <span class="n">keys</span><span class="p">)</span>
<span class="linenos">4</span>    <span class="n">key</span> <span class="o">=</span> <span class="n">generate_canonical</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">digits</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
<span class="linenos">5</span>
<span class="linenos">6</span><span class="n">algorithm</span><span class="p">.</span><span class="n">injectChromosome</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">.</span><span class="n">population_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="implicit-path-relink">
<span id="doxid-guide-guide-ipr"></span><h3>Implicit Path Relink<a class="headerlink" href="#implicit-path-relink" title="Link to this heading"></a></h3>
<p>The Implicit Path Relinking (IPR) is a nice addition to the standard BRKGA
framework, and it provides an excellent way to create hybrid heuristics and
push the optimization further. The good thing about IPR is that you do not
need to worry about the path relink implementation, which can be long and
tedious if done by hand or customized per problem.</p>
<p>BRKGA-MP-IPR provides a friendly interface to use IPR directly from the BRKGA
population, and you only must provide a few functions and arguments to have a
Path Relink algorithm ready to go. These are the two main signatures:
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aa8da5193248d23ced19e68483aca31a5"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::pathRelink(/*long</span> <span class="pre">args</span> <span class="pre">call*/)</span></span></a></code>
and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1ae9c15595bc46c3554b3eb5656ab08a53"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::pathRelink(/*short</span> <span class="pre">args</span> <span class="pre">call*/)</span></span></a></code>,
and these are their signatures:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">// Long list of arguments.</span>
<span class="linenos"> 2</span><span class="n">PathRelinking</span><span class="o">::</span><span class="n">PathRelinkingResult</span> <span class="n">pathRelink</span><span class="p">(</span>
<span class="linenos"> 3</span>    <span class="n">PathRelinking</span><span class="o">::</span><span class="n">Type</span> <span class="n">pr_type</span><span class="p">,</span>
<span class="linenos"> 4</span>    <span class="n">PathRelinking</span><span class="o">::</span><span class="n">Selection</span> <span class="n">pr_selection</span><span class="p">,</span>
<span class="linenos"> 5</span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DistanceFunctionBase</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">,</span>
<span class="linenos"> 6</span>    <span class="kt">unsigned</span> <span class="n">number_pairs</span><span class="p">,</span>
<span class="linenos"> 7</span>    <span class="kt">double</span> <span class="n">minimum_distance</span><span class="p">,</span>
<span class="linenos"> 8</span>    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="linenos"> 9</span>    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span> <span class="n">max_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span>
<span class="linenos">10</span>    <span class="kt">double</span> <span class="n">percentage</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="linenos">11</span><span class="p">)</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="c1">// Short list of arguments.</span>
<span class="linenos">14</span><span class="n">PathRelinking</span><span class="o">::</span><span class="n">PathRelinkingResult</span> <span class="n">pathRelink</span><span class="p">(</span>
<span class="linenos">15</span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DistanceFunctionBase</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">,</span>
<span class="linenos">16</span>    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span> <span class="n">max_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="linenos">17</span><span class="p">)</span>
</pre></div>
</div>
<p>The first argument defines the type of implicit path relink to be performed
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_Type.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a79247d22aeb1fa9ab7611488e8137132"><span class="std std-ref"><span class="pre">BRKGA::PathRelinking::Type</span></span></a></code>.
The
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_Type.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a79247d22aeb1fa9ab7611488e8137132a4c5d06b02c97731aaa976179c62dcf76"><span class="std std-ref"><span class="pre">DIRECT</span></span></a></code>
path relink exchanges the keys of two chromosomes directly, and
it is usually more suitable to or threshold representations, i.e., where the
key values are used to some kind of discretization, such as <em>“if x &lt; 0.5, then
0, otherwise 1.”</em>
The
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_Type.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a79247d22aeb1fa9ab7611488e8137132a48deaef68056f516e0091a15c1db3daa"><span class="std std-ref"><span class="pre">PERMUTATION</span></span></a></code>
path relink switches the order of a key
according to its position in the other chromosome. Usually, this kind of path
relink is more suitable to permutation representations, where the chromosome
induces an order or permutation. For example, chromosome <code class="docutils literal notranslate"><span class="pre">[0.4,</span> <span class="pre">0.7,</span> <span class="pre">0.1]</span></code>
may induce the increasing order <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">1,</span> <span class="pre">2)</span></code>. More details about threshold and
permutation representations in <span id="id17">[<a class="reference internal" href="#id34" title="Carlos E. Andrade, Rodrigo F. Toso, José F. Gonçalves, and Mauricio G. C. Resende. The multi-parent biased random-key genetic algorithm with implicit path-relinking and its real-world applications. European Journal of Operational Research, 289(1):17–30, 2021. doi:10.1016/j.ejor.2019.11.037.">ATGR21</a>]</span>.</p>
<p><code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_Selection.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a3ce8f0aeb5c0063aab2e8cbaee3076fa"><span class="std std-ref"><span class="pre">BRKGA::PathRelinking::Selection</span></span></a></code>
defines how the algorithm picks the chromosomes for relinking.
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_Selection.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a3ce8f0aeb5c0063aab2e8cbaee3076faa6a169dcc4781fa0dc8c448d550be9d39"><span class="std std-ref"><span class="pre">BESTSOLUTION</span></span></a></code>
selects, in the order, the best solution of each population.
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_Selection.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a3ce8f0aeb5c0063aab2e8cbaee3076faa80e0b7674eebae1977705eed127c6ee8"><span class="std std-ref"><span class="pre">RANDOMELITE</span></span></a></code>
chooses uniformly random solutions from the elite sets.</p>
<p>The next argument is a pointer to a functor object used to compute the distance
between two chromosomes, and determine if changes in a given (block) of alleles
change the solution. This object must inherit from
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_DistanceFunctionBase.html#doxid-class-b-r-k-g-a-1-1-distance-function-base"><span class="std std-ref"><span class="pre">BRKGA::DistanceFunctionBase</span></span></a></code>, which has the following
signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="n">DistanceFunctionBase</span> <span class="p">{</span>
<span class="linenos"> 2</span><span class="k">public</span><span class="o">:</span>
<span class="linenos"> 3</span>    <span class="k">virtual</span> <span class="kt">double</span> <span class="n">distance</span><span class="p">(</span>
<span class="linenos"> 4</span>        <span class="k">const</span> <span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span>
<span class="linenos"> 5</span>        <span class="k">const</span> <span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">v2</span>
<span class="linenos"> 6</span>    <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span>    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">affectSolution</span><span class="p">(</span>
<span class="linenos"> 9</span>        <span class="k">const</span> <span class="n">Chromosome</span><span class="o">::</span><span class="n">value_type</span> <span class="n">key1</span><span class="p">,</span>
<span class="linenos">10</span>        <span class="k">const</span> <span class="n">Chromosome</span><span class="o">::</span><span class="n">value_type</span> <span class="n">key2</span>
<span class="linenos">11</span>    <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="linenos">12</span>
<span class="linenos">13</span>    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">affectSolution</span><span class="p">(</span>
<span class="linenos">14</span>        <span class="n">Chromosome</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">v1_begin</span><span class="p">,</span>
<span class="linenos">15</span>        <span class="n">Chromosome</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">v2_begin</span><span class="p">,</span>
<span class="linenos">16</span>        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span>
<span class="linenos">17</span>    <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="linenos">18</span><span class="p">};</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_DistanceFunctionBase.html#doxid-class-b-r-k-g-a-1-1-distance-function-base"><span class="std std-ref"><span class="pre">BRKGA::DistanceFunctionBase</span></span></a></code> is an abstract interface,
and children classes must implement all methods.</p>
<p>If the value returned by method <code class="docutils literal notranslate"><span class="pre">distance()</span></code> is greater than or equal to
<code class="docutils literal notranslate"><span class="pre">minimum_distance</span></code> (on <code class="docutils literal notranslate"><span class="pre">pathRelink()</span></code> arguments), the algorithm will perform
the path relink between the two chromosomes. Otherwise, it will look for another
pair of chromosomes. The algorithm will try <code class="docutils literal notranslate"><span class="pre">number_pairs</span></code> chromosomes before
gives up. In the presence of multiple populations, the path relinking is
performed between elite chromosomes from different populations, in a circular
fashion. For example, suppose we have 3 populations. The framework performs 3
path relinkings: the first between individuals from populations 1 and 2, the
second between populations 2 and 3, and the third between populations 3 and 1.
In the case of just one population, both base and guiding individuals are
sampled from the elite set of that population.</p>
<p>Note that in traditional path relink algorithms, method <code class="docutils literal notranslate"><span class="pre">distance()</span></code> depends
on the problem structure. On IPR, you can use a generic distance function, or
provide one that incorporates more knowledge about the problem. BRKGA-MP-IPR
provides a class/functor to compute the (modified)
<a class="reference external" href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a>
for threshold representations (<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_HammingDistance.html#doxid-class-b-r-k-g-a-1-1-hamming-distance"><span class="std std-ref"><span class="pre">BRKGA::HammingDistance</span></span></a></code>),
and a class/functor that computes the
<a class="reference external" href="https://en.wikipedia.org/wiki/Kendall_tau_distance">Kendall Tau distance</a>
distance for permutation representations (<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_KendallTauDistance.html#doxid-class-b-r-k-g-a-1-1-kendall-tau-distance"><span class="std std-ref"><span class="pre">BRKGA::KendallTauDistance</span></span></a></code>). Again, details about
threshold and permutation representations in <span id="id18">[<a class="reference internal" href="#id34" title="Carlos E. Andrade, Rodrigo F. Toso, José F. Gonçalves, and Mauricio G. C. Resende. The multi-parent biased random-key genetic algorithm with implicit path-relinking and its real-world applications. European Journal of Operational Research, 289(1):17–30, 2021. doi:10.1016/j.ejor.2019.11.037.">ATGR21</a>]</span>.</p>
<p>As a simple example, suppose you are using a threshold representation where
each chromosome key can represent one of 3 different values (a ternary
threshold representation). So, one possible way to compute the distance between
two chromosomes can be:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="nl">TernaryHammingDistance</span><span class="p">:</span> <span class="k">public</span> <span class="n">DistanceFunctionBase</span> <span class="p">{</span>
<span class="linenos"> 2</span><span class="k">protected</span><span class="o">:</span>
<span class="linenos"> 3</span>    <span class="kt">double</span> <span class="n">value</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="linenos"> 4</span>        <span class="k">return</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mf">0.33</span> <span class="o">?</span> <span class="mf">0.0</span> <span class="o">:</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="mf">0.66</span> <span class="o">?</span> <span class="mf">1.0</span> <span class="o">:</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="linenos"> 5</span>    <span class="p">}</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="k">public</span><span class="o">:</span>
<span class="linenos"> 8</span>    <span class="k">explicit</span> <span class="n">TernaryHammingDistance</span><span class="p">()</span> <span class="p">{}</span>
<span class="linenos"> 9</span>    <span class="k">virtual</span> <span class="o">~</span><span class="n">TernaryHammingDistance</span><span class="p">()</span> <span class="p">{}</span>
<span class="linenos">10</span>
<span class="linenos">11</span>    <span class="k">virtual</span> <span class="kt">double</span> <span class="n">distance</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">vector1</span><span class="p">,</span>
<span class="linenos">12</span>                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">vector2</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
<span class="linenos">13</span>        <span class="kt">double</span> <span class="n">dist</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="linenos">14</span>        <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vector1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="linenos">15</span>            <span class="n">dist</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="n">vector1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">value</span><span class="p">(</span><span class="n">vector2</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="linenos">16</span>        <span class="k">return</span> <span class="n">dist</span><span class="p">;</span>
<span class="linenos">17</span>    <span class="p">}</span>
<span class="linenos">18</span>
<span class="linenos">19</span>    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">affectSolution</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="n">key2</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
<span class="linenos">20</span>        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">(</span><span class="n">key2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="linenos">21</span>    <span class="p">}</span>
<span class="linenos">22</span>
<span class="linenos">23</span>    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">affectSolution</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">v1_begin</span><span class="p">,</span>
<span class="linenos">24</span>                                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">v2_begin</span><span class="p">,</span>
<span class="linenos">25</span>                                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">block_size</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
<span class="linenos">26</span>        <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">block_size</span><span class="p">;</span>
<span class="linenos">27</span>            <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">v1_begin</span><span class="p">,</span> <span class="o">++</span><span class="n">v2_begin</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">28</span>            <span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">value</span><span class="p">(</span><span class="o">*</span><span class="n">v1_begin</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">(</span><span class="o">*</span><span class="n">v2_begin</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="linenos">29</span>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="linenos">30</span>        <span class="p">}</span>
<span class="linenos">31</span>        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="linenos">32</span>    <span class="p">}</span>
<span class="linenos">33</span><span class="p">};</span>
</pre></div>
</div>
<p>To avoid changes that do not lead to new solutions, we must verify if such key
exchanges affect the solution. For that, the distance functor object must
implement the methods <code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code>, which come with two signatures,
depicted in the previous example.</p>
<p>In the first version, <code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code> takes two keys and check whether the
exchange of <code class="docutils literal notranslate"><span class="pre">key1</span></code> by <code class="docutils literal notranslate"><span class="pre">key2</span></code> could change the solution. If so, the method
returns <code class="docutils literal notranslate"><span class="pre">true</span></code>. The second version takes two iterators for two chromosomes
and checks <code class="docutils literal notranslate"><span class="pre">block_size</span></code> keys from those iterators. The idea is, instead to
check only individual keys, we check an entire block of keys. This is very
usual for path relinks that exchange blocks of keys instead individual ones.
For instance, suppose that the alleles/keys are used as threshold such that
values &gt; 0.5 activate a feature. Suppose we have <code class="docutils literal notranslate"><span class="pre">chromosome1</span> <span class="pre">=</span> <span class="pre">[0.3,</span> <span class="pre">0.4,</span>
<span class="pre">0.1,</span> <span class="pre">0.8]</span></code> and <code class="docutils literal notranslate"><span class="pre">chromosome2</span> <span class="pre">=</span> <span class="pre">[0.6,</span> <span class="pre">0.1,</span> <span class="pre">0.2,</span> <span class="pre">0.9]</span></code>. If the key blocks start
on the first keys, and <code class="docutils literal notranslate"><span class="pre">block_size</span> <span class="pre">=</span> <span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code> will return
<code class="docutils literal notranslate"><span class="pre">true</span></code> since the very first keys have different activation value. However, if
we start from the 3rd keys and exchange blocks of 2 keys (<code class="docutils literal notranslate"><span class="pre">[0.4,</span> <span class="pre">0.1]</span></code> by
<code class="docutils literal notranslate"><span class="pre">[0.1,</span> <span class="pre">0.2]</span></code>), nothing changes since both values have the same activation
level (&lt; 0.5). The blocks can hold only one key/allele, sequential key blocks,
or even the whole chromosome.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code> is crucial to the IPR performance since this
function helps to avoid exploring regions already surveyed. Also, note that
<code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code> can incorporate some problem knowledge.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The current implementation of permutation path relink does not make use of
<code class="docutils literal notranslate"><span class="pre">affectSolution()</span></code>. However, <code class="docutils literal notranslate"><span class="pre">pathRelink()</span></code> requires the function.
Therefore, we can implement simple constant methods:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span>  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">affectSolution</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
<span class="linenos">2</span>      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="linenos">3</span>  <span class="p">}</span>
<span class="linenos">4</span>
<span class="linenos">5</span>  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">affectSolution</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="p">,</span>
<span class="linenos">6</span>                              <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="p">,</span>
<span class="linenos">7</span>                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
<span class="linenos">8</span>      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="linenos">9</span>  <span class="p">}</span>
</pre></div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">block_size</span></code> defines the number of keys / size of the chromosome block to be
exchanged during the direct path relink. This parameter is also critical for
IPR performance since it avoids too many exchanges during the path building.
Usually, we can compute this number based on the size of the chromosome by some
factor (
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params-1a40ff7da597d2c4eadabf3f62b3b9196d"><span class="std std-ref"><span class="pre">BrkgaParams::alpha_block_size</span></span></a></code>
in the configuration file), chosen by you.
Again, details in <span id="id19">[<a class="reference internal" href="#id34" title="Carlos E. Andrade, Rodrigo F. Toso, José F. Gonçalves, and Mauricio G. C. Resende. The multi-parent biased random-key genetic algorithm with implicit path-relinking and its real-world applications. European Journal of Operational Research, 289(1):17–30, 2021. doi:10.1016/j.ejor.2019.11.037.">ATGR21</a>]</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Experiments have shown that a good choice is
<span class="math notranslate nohighlight">\(block\_size = alpha\_block\_size \times \sqrt{size~of~chromosome}\)</span></p>
</div>
<p>The last two parameters are stopping criteria. The algorithm stops either when
<code class="docutils literal notranslate"><span class="pre">max_time</span></code> seconds is reached or <code class="docutils literal notranslate"><span class="pre">percentage%</span></code> of the path is built.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>IPR is a very time-intensive process. You must set the stopping criteria
accordingly.</strong></p>
</div>
<p>Let’s see how can we call IPR. As example, take the TSP for which we use
the permutation-based IPR, and the Kendall Tau distance functions.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DistanceFunctionBase</span><span class="o">&gt;</span> <span class="n">dist_func</span> <span class="p">{</span><span class="k">new</span> <span class="n">KendallTauDistance</span><span class="p">};</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">.</span><span class="n">pathRelink</span><span class="p">(</span>
<span class="linenos"> 4</span>    <span class="n">brkga_params</span><span class="p">.</span><span class="n">pr_type</span><span class="p">,</span>
<span class="linenos"> 5</span>    <span class="n">brkga_params</span><span class="p">.</span><span class="n">pr_selection</span><span class="p">,</span>
<span class="linenos"> 6</span>    <span class="n">dist_func</span><span class="p">,</span>
<span class="linenos"> 7</span>    <span class="n">brkga_params</span><span class="p">.</span><span class="n">pr_number_pairs</span><span class="p">,</span>
<span class="linenos"> 8</span>    <span class="mi">1</span><span class="p">,</span> <span class="c1">// block_size doesn&#39;t not matter for permutation.</span>
<span class="linenos"> 9</span>    <span class="n">max_time</span> <span class="o">-</span> <span class="n">elapsedFrom</span><span class="p">(</span><span class="n">start_time</span><span class="p">),</span>
<span class="linenos">10</span>    <span class="n">brkga_params</span><span class="p">.</span><span class="n">pr_percentage</span>
<span class="linenos">11</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that most parameters come from <code class="docutils literal notranslate"><span class="pre">brkga_params</span></code>. The maximum IPR time is
set to the remaining time for optimization (global <code class="docutils literal notranslate"><span class="pre">maximum_time</span></code> minus the
elapsed time).
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1aa8da5193248d23ced19e68483aca31a5"><span class="std std-ref"><span class="pre">pathRelink()</span></span></a></code>
returns a
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_PathRelinkingResult.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a64da27c4c7ed94712c1547d972de6253"><span class="std std-ref"><span class="pre">BRKGA::PathRelinking::PathRelinkingResult</span></span></a></code>
object which defines the status of the IPR optimization. Four situation may
happen:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_PathRelinkingResult.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a64da27c4c7ed94712c1547d972de6253afc79eaa94186dcf0eda5c1df7bd87001"><span class="std std-ref"><span class="pre">TOO_HOMOGENEOUS</span></span></a></code>
The chromosomes among the populations are too homogeneous and the path relink
will not generate improveded solutions. This status is directly linked to
the chosen distance function and minimum distance. If the minimum distance is
too large, IPR may not be able to find a pair of chromosomes far enough for
path relink;</p></li>
<li><p><code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_PathRelinkingResult.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a64da27c4c7ed94712c1547d972de6253ae7339868191fd122c45d9abb0dcb87e9"><span class="std std-ref"><span class="pre">NO_IMPROVEMENT</span></span></a></code>
Path relink was done but no improveded solution was found;</p></li>
<li><p><code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_PathRelinkingResult.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a64da27c4c7ed94712c1547d972de6253ae523f249a5e460a70f2ae8ac7d7a959b"><span class="std std-ref"><span class="pre">ELITE_IMPROVEMENT</span></span></a></code>
An improved solution among the elite set was found, but the best solution was
not improved;</p></li>
<li><p><code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_PathRelinking_PathRelinkingResult.html#doxid-namespace-b-r-k-g-a-1-1-path-relinking-1a64da27c4c7ed94712c1547d972de6253a44ea02fc8a02805c8ddfe8d37d101a39"><span class="std std-ref"><span class="pre">BEST_IMPROVEMENT</span></span></a></code>
The best solution was improved.</p></li>
</ul>
<p>If the found solution is the best solution found so far, IPR replaces the worst
solution by it. Otherwise, IPR computes the distance between the found solution
and all other solutions in the elite set, and replaces the worst solution by it
if and only if the found solution is, at least, <code class="docutils literal notranslate"><span class="pre">minimum_distance</span></code> from all
them.</p>
<section id="important-notes-about-ipr">
<h4>Important notes about IPR<a class="headerlink" href="#important-notes-about-ipr" title="Link to this heading"></a></h4>
<p>IPR will call <code class="docutils literal notranslate"><span class="pre">decode()</span></code> function always with <code class="docutils literal notranslate"><span class="pre">writeback</span> <span class="pre">=</span> <span class="pre">false</span></code>. The
reason is that if the decoder rewrites the chromosome, the path between
solutions is lost and inadvertent results may come up. Note that at the end of
the path relinking, the method calls the decoder with <code class="docutils literal notranslate"><span class="pre">writeback</span> <span class="pre">=</span> <span class="pre">true</span></code> in
the best chromosome found to guarantee that this chromosome is re-written to
reflect the best solution found.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Make sure your decoder does not rewrite the chromosome when called with the
argument <code class="docutils literal notranslate"><span class="pre">writeback</span> <span class="pre">=</span> <span class="pre">false</span></code>.</p>
</div>
<p>BRKGA-MP-IPR <code class="docutils literal notranslate"><span class="pre">pathRelink()</span></code> implementation is multi-threaded. Instead of to
build and decode each chromosome one at a time, the method builds a list of
candidates, altering the alleles/keys according to the guide solution, and then
decode all candidates in parallel. Note that
<span class="math notranslate nohighlight">\(O(chromosome\_size^2~/~block\_size)\)</span> additional memory is necessary to
build the candidates, which can be costly if the <code class="docutils literal notranslate"><span class="pre">chromosome_size</span></code> is very
large.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>As it is in method <code class="docutils literal notranslate"><span class="pre">evolve()</span></code>, the decoding is done in parallel using
threads, and the user <strong>must guarantee that the decoder is THREAD-SAFE.</strong>
If such property cannot be held, we suggest using a single thread for
optimization.</p>
</div>
</section>
</section>
<section id="shaking">
<span id="doxid-guide-guide-shaking"></span><h3>Shaking<a class="headerlink" href="#shaking" title="Link to this heading"></a></h3>
<p>Sometimes, BRKGA gets stuck, converging to local maxima/minima, for several
iterations. When such a situation happens, it is a good idea to perturb the
population, or even restart from a new one completely new. BRKGA-MP-IPR offers
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a3721a91ed9d3fcbdc57fbcee2e20ac66"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::shake()</span></span></a></code>,
an improved variation of the original version proposed in
<span id="id20">[<a class="reference internal" href="#id37" title="Carlos E. Andrade, Thuener Silva, and Luciana S. Pessoa. Minimizing flowtime in a flowshop scheduling problem with a biased random-key genetic algorithm. Expert Systems with Applications, 128:67–80, Aug 2019. doi:10.1016/j.eswa.2019.03.007.">ASP19</a>]</span>. This is the signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kt">void</span> <span class="n">shake</span><span class="p">(</span>
<span class="linenos">2</span>    <span class="kt">unsigned</span> <span class="n">intensity</span><span class="p">,</span>
<span class="linenos">3</span>    <span class="n">ShakingType</span> <span class="n">shaking_type</span><span class="p">,</span>
<span class="linenos">4</span>    <span class="kt">unsigned</span> <span class="n">population_index</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">()</span>
<span class="linenos">5</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a3721a91ed9d3fcbdc57fbcee2e20ac66"><span class="std std-ref"><span class="pre">shake()</span></span></a></code>,
method gets an <code class="docutils literal notranslate"><span class="pre">intensity</span></code> parameter that measures how many times
the perturbation is applied on the elite set for a given <code class="docutils literal notranslate"><span class="pre">population_index</span></code>
(if not given, all populations are shaken). This method offers two
canonial/generic
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_ShakingType.html#doxid-namespace-b-r-k-g-a-1a616e3d7dedad5ff4e6a2961cda1ea494"><span class="std std-ref"><span class="pre">BRKGA::ShakingType</span></span></a></code>’s.
With
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_ShakingType.html#doxid-namespace-b-r-k-g-a-1a616e3d7dedad5ff4e6a2961cda1ea494a421cfd143e450c3f5814a0495409e073"><span class="std std-ref"><span class="pre">CHANGE</span></span></a></code>,
direct modifications are done in the keys/alleles. This kind of
shaking is recommended when the chromosome uses direct or threshold
representations.
<code class="docutils literal notranslate"><a class="reference internal" href="enum_BRKGA_ShakingType.html#doxid-namespace-b-r-k-g-a-1a616e3d7dedad5ff4e6a2961cda1ea494a46fc23bc4e4d57e5469a39658a6dd3e8"><span class="std std-ref"><span class="pre">SWAP</span></span></a></code>
exchanges keys/alleles inducing new permutations.
For representational definitions, please refer to
<span id="id21">[<a class="reference internal" href="#id34" title="Carlos E. Andrade, Rodrigo F. Toso, José F. Gonçalves, and Mauricio G. C. Resende. The multi-parent biased random-key genetic algorithm with implicit path-relinking and its real-world applications. European Journal of Operational Research, 289(1):17–30, 2021. doi:10.1016/j.ejor.2019.11.037.">ATGR21</a>]</span>. For instance, the following code shakes
all populations using 10 swap moves:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">shake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">ShakingTypeSWAP</span><span class="p">);</span>
</pre></div>
</div>
<p>Sometimes, the provided shaking are not appropriated to the problem being solved.
In this case, the user can provide a custom shaking procedure. Please, take a
look on section
<a class="reference internal" href="#doxid-guide-providing-custom-shake"><span class="std std-ref">Providing custom shake procedure</span></a>.</p>
</section>
<section id="resetting">
<span id="doxid-guide-guide-resetting"></span><h3>Resetting<a class="headerlink" href="#resetting" title="Link to this heading"></a></h3>
<p>Sometimes, even shaking the populations does not help to escape from local
maxima/minima. So, we need a drastic measure, restarting from scratch the role
population. This can be easily accomplished with
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a3bfe66221dd2f9c755a65ed7df14e350"><span class="std std-ref"><span class="pre">BRKGA::BRKGA_MP_IPR::reset()</span></span></a></code>.</p>
<pre class="highlight literal-block"><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">reset()</span></code>, all warm-start solutions provided by
<code class="docutils literal notranslate"><span class="pre">setInitialPopulation()</span></code> are discarded. You may use <code class="docutils literal notranslate"><span class="pre">injectChromosome()</span></code>
to insert those solutions again.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Again, the decoding of each chromosome is done in parallel if multi-thread is
enabled. Therefore, <strong>we must guarantee that the decoder is THREAD-SAFE.</strong> If
such property cannot be held, we suggest using a single thread..</p>
</div>
</section>
<section id="multi-population-and-migration">
<span id="doxid-guide-guide-migration"></span><h3>Multi-population and migration<a class="headerlink" href="#multi-population-and-migration" title="Link to this heading"></a></h3>
<p>Multi-population or <em>island model</em> was introduced in genetic algorithms in
<span id="id22">[<a class="reference internal" href="#id66" title="Darrell Whitley, Soraya Rana, and Robert B. Heckendorn. The island model genetic algorithm: On separability, population size and convergence. Journal of Computing and Information Technology, 7:33–47, 1998. URL: https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.7225.">WRH98</a>]</span>.
The idea is to evolve parallel and independent populations and, once a while,
exchange individuals among these populations. In several scenarios, this
approach is very beneficial for optimization.</p>
<p>BRKGA-MP-IPR is implemented using such island idea from the core. If you read
the guide until here, you may notice that several methods take into account
multiple populations. To use multiple populations, you must set
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params-1a9a4a99536f6b755ceb07b54d784f8926"><span class="std std-ref"><span class="pre">BrkgaParams::num_independent_populations</span></span></a></code>
with 2 or more populations, and build the BRKGA algorithm from such parameters.</p>
<p>The immigration process is implemented by method
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1ab89298e6c633a81bf8c0462fb40ddd15"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::exchangeElite()</span></span></a></code>
which has the following signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">exchangeElite</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">num_immigrants</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1ab89298e6c633a81bf8c0462fb40ddd15"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::exchangeElite()</span></span></a></code>
copies <code class="docutils literal notranslate"><span class="pre">num_immigrants</span></code> from one population to another, replacing the worst
<code class="docutils literal notranslate"><span class="pre">num_immigrants</span></code> individuals from the recipient population. Note that the
migration is done for all pairs of populations. For instance, the following
code exchanges 3 best individuals from each population:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">algorithm</span><span class="p">.</span><span class="n">exchangeElite</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="simulating-the-standard-brkga">
<span id="doxid-guide-guide-standard-brkga"></span><h2>Simulating the standard BRKGA<a class="headerlink" href="#simulating-the-standard-brkga" title="Link to this heading"></a></h2>
<p>Sometimes, it is a good idea to test how the standard BRKGA algorithm performs
for a problem. You can use BRKGA-MP-IPR framework to quickly implement and test
a standard BRKGA.</p>
<p>First, you must guarantee that, during the crossover, the algorithm chooses
only one elite individual and only one non-elite individual. This is easily
accomplished setting <code class="docutils literal notranslate"><span class="pre">num_elite_parents</span> <span class="pre">=</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">total_parents</span> <span class="pre">=</span> <span class="pre">2</span></code>. Then,
you must set up a bias function that ranks the elite and no-elite individual
according to the original BRKGA bias parameter <span class="math notranslate nohighlight">\(\rho\)</span> (rho).</p>
<p>You can use
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BRKGA_MP_IPR.html#doxid-class-b-r-k-g-a-1-1-b-r-k-g-a-m-p-i-p-r-1a8616c89626ca3c8e8d3b5adb1da24c92"><span class="std std-ref"><span class="pre">BRKGA_MP_IPR::setBiasCustomFunction()</span></span></a></code>
for that task. The given function should receive the index of the chromosome and
returns a ranking for it. Such ranking is used in the roulette method to choose
the individual from which each allele comes to build the new chromosome. Since
we have one two individuals for crossover in the standard BRKGA, the bias
function must return the probability to one or other individual. In the
following code, we do that with a simple <code class="docutils literal notranslate"><span class="pre">if...else</span></code> lambda function.</p>
<pre class="highlight literal-block"><span></span><span class="c1">// Create brkga_params by hand or reading from a file,</span>
<span class="c1">// then set the following by hand.</span>
<span class="n">brkga_params</span><span class="p">.</span><span class="n">num_elite_parents</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">brkga_params</span><span class="p">.</span><span class="n">total_parents</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1">// This is the original parameter rho form the vanilla BRKGA.</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">;</span>

<span class="n">algorithm</span><span class="p">.</span><span class="n">setBiasCustomFunction</span><span class="o">!</span><span class="p">(</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="nl">rho</span> <span class="p">:</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">rho</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">);</span></pre>
<p>Here, we first set the <code class="docutils literal notranslate"><span class="pre">num_elite_parents</span> <span class="pre">=</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">total_parents</span> <span class="pre">=</span> <span class="pre">2</span></code> as
explained before. Following, we set a variable <code class="docutils literal notranslate"><span class="pre">rho</span> <span class="pre">=</span> <span class="pre">0.75</span></code>. This is the
<span class="math notranslate nohighlight">\(\rho\)</span> from standard BRKGA, and you may set it as you wish. Then, we set
the bias function as a very simple lambda function (note that we must use
<code class="docutils literal notranslate"><span class="pre">[&amp;]</span></code> to capture <code class="docutils literal notranslate"><span class="pre">rho</span></code> in the outside context). So, if the index of the
chromosome is 1 (elite individual), it gets a 0.75 rank/probability. If the
index is 2 (non-elite individual), the chromosome gets 0.25 rank/probability.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Note that we consider the index 1 as the elite individual instead index 0,
and index 2 to the non-elite individual opposed to index 1. The reason
for this is that, internally, BRKGA always pass <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> to the bias
function to avoid division-by-zero exceptions.</p>
</div>
</section>
<section id="reading-and-writing-parameters">
<span id="doxid-guide-guide-parameters"></span><h2>Reading and writing parameters<a class="headerlink" href="#reading-and-writing-parameters" title="Link to this heading"></a></h2>
<p>Although we can build the BRKGA algorithm data by set up a
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BrkgaParams</span></span></a></code> object
manually, the easiest way to do so is to read such parameters from a
configuration file. For this, we can use
<code class="docutils literal notranslate"><a class="reference internal" href="group_brkga_control_params.html#doxid-group-brkga-control-params-1ga1c8b456ad75a3b522d315d4167546ae6"><span class="std std-ref"><span class="pre">BRKGA::readConfiguration()</span></span></a></code>
that reads a simple plain text file and returns a tuple of
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code>
and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">BRKGA::ControlParams</span></span></a></code>
objects. For instance,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="p">[</span><span class="n">brkga_params</span><span class="p">,</span> <span class="n">control_params</span><span class="p">]</span> <span class="o">=</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">readConfiguration</span><span class="p">(</span><span class="s">&quot;tuned_conf.txt&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The configuration file must be plain text such that contains pairs of
parameter name and value.
In <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/tree/master/examples/tsp">examples folder</a>, we
have <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/config.conf">config.conf</a>
that looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1"># BRKGA and IPR parameters</span>
<span class="linenos"> 2</span><span class="n">population_size</span> <span class="mi">2000</span>
<span class="linenos"> 3</span><span class="n">elite_percentage</span> <span class="mf">0.30</span>
<span class="linenos"> 4</span><span class="n">mutants_percentage</span> <span class="mf">0.15</span>
<span class="linenos"> 5</span><span class="n">num_elite_parents</span> <span class="mi">2</span>
<span class="linenos"> 6</span><span class="n">total_parents</span> <span class="mi">3</span>
<span class="linenos"> 7</span><span class="n">bias_type</span> <span class="n">LOGINVERSE</span>
<span class="linenos"> 8</span><span class="n">num_independent_populations</span> <span class="mi">3</span>
<span class="linenos"> 9</span><span class="n">pr_number_pairs</span> <span class="mi">0</span>
<span class="linenos">10</span><span class="n">pr_minimum_distance</span> <span class="mf">0.15</span>
<span class="linenos">11</span><span class="n">pr_type</span> <span class="n">DIRECT</span>
<span class="linenos">12</span><span class="n">pr_selection</span> <span class="n">BESTSOLUTION</span>
<span class="linenos">13</span><span class="n">pr_distance_function_type</span> <span class="n">KENDALLTAU</span>
<span class="linenos">14</span><span class="n">alpha_block_size</span> <span class="mf">1.0</span>
<span class="linenos">15</span><span class="n">pr_percentage</span> <span class="mf">1.0</span>
<span class="linenos">16</span><span class="n">num_exchange_individuals</span> <span class="mi">1</span>
<span class="linenos">17</span><span class="n">shaking_type</span> <span class="n">SWAP</span>
<span class="linenos">18</span><span class="n">shaking_intensity_lower_bound</span> <span class="mf">0.25</span>
<span class="linenos">19</span><span class="n">shaking_intensity_upper_bound</span> <span class="mf">0.75</span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="c1"># Control parameters</span>
<span class="linenos">22</span><span class="n">maximum_running_time</span> <span class="mi">60</span>
<span class="linenos">23</span><span class="n">exchange_interval</span> <span class="mi">100</span>
<span class="linenos">24</span><span class="n">ipr_interval</span> <span class="mi">200</span>
<span class="linenos">25</span><span class="n">shake_interval</span> <span class="mi">300</span>
<span class="linenos">26</span><span class="n">reset_interval</span> <span class="mi">500</span>
<span class="linenos">27</span><span class="n">stall_offset</span> <span class="mi">100</span>
</pre></div>
</div>
<p>It does not matter whether we use lower or upper cases. Blank lines and lines
starting with <code class="docutils literal notranslate"><span class="pre">#</span></code> are ignored. The order of the parameters should not
matter either. And, finally, this file should be readable for both C++, Julia,
and Python framework versions (when all come to the same version number).</p>
<p>In some cases, you define some of the parameters at the running time, and you
may want to save them for debug or posterior use. To do so, you can use
<code class="docutils literal notranslate"><a class="reference internal" href="group_brkga_control_params.html#doxid-group-brkga-control-params-1ga758c489d2f6291cf80a78ca6765b856e"><span class="std std-ref"><span class="pre">BRKGA::writeConfiguration()</span></span></a></code>,
call upon a <code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BrkgaParams</span></span></a></code> object.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">writeConfiguration</span><span class="p">(</span><span class="s">&quot;test.conf&quot;</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">);</span>
<span class="linenos">2</span><span class="c1">//or</span>
<span class="linenos">3</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">writeConfiguration</span> <span class="p">(</span><span class="s">&quot;test.conf&quot;</span><span class="p">,</span> <span class="n">brkga_params</span><span class="p">,</span> <span class="n">control_params</span><span class="p">);</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">control_params</span></code> is not given, default values are used in its place.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><a class="reference internal" href="group_brkga_control_params.html#doxid-group-brkga-control-params-1ga758c489d2f6291cf80a78ca6765b856e"><span class="std std-ref"><span class="pre">BRKGA::writeConfiguration()</span></span></a></code>
rewrites the given file. So, watch out to not lose previous configurations.</p>
</div>
</section>
<section id="using-brkga-mp-ipr-on-multi-objective-mode">
<span id="doxid-guide-guide-multi-obj"></span><h2>Using BRKGA-MP-IPR on multi-objective mode<a class="headerlink" href="#using-brkga-mp-ipr-on-multi-objective-mode" title="Link to this heading"></a></h2>
<p>As stated in the introduction, BRKGA-MP-IPR also deals with multiple objectives
in a lexicographical or priority dominance order. Differing from classical
non-dominance order (using Pareto frontiers), the lexicographical order defines
a <em>strict preference order among the objective functions.</em> This leads us to a
partial ordering of the values of the solutions (composed of several values,
each one from one objective function). So, we have the following definition
(abusing a little bit of notation).</p>
<div class="admonition-definition admonition">
<p class="admonition-title">Definition</p>
<p>Let <span class="math notranslate nohighlight">\(A = (f_1, f_2, \ldots, f_n)\)</span> and
<span class="math notranslate nohighlight">\(A' = (f'_1, f'_2, \ldots, f'_n)\)</span>
be two vectors for <span class="math notranslate nohighlight">\(n\)</span> functions <span class="math notranslate nohighlight">\(f_1, f_2, \ldots, f_n\)</span>.
<span class="math notranslate nohighlight">\(A\)</span> is lexicographical smaller than <span class="math notranslate nohighlight">\(A'\)</span>, i.e.,
<span class="math notranslate nohighlight">\(A &lt; A'\)</span> if and only if
<span class="math notranslate nohighlight">\(f_1 &lt; f'_1\)</span>, or
<span class="math notranslate nohighlight">\(f_1 = f'_1\)</span> and <span class="math notranslate nohighlight">\(f_2 &lt; f'_2\)</span>, or
<span class="math notranslate nohighlight">\(\ldots, f_1 = f'_1, \ldots, f_{n-1} = f'_{n-1}\)</span>
and <span class="math notranslate nohighlight">\(f_n &lt; f'_n\)</span>.</p>
</div>
<p>For instance, let’s assume we have three minimizing objective functions and
four solutions described in the following table:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Solution</p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(f_1\)</span></p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(f_2\)</span></p></th>
<th class="head"><p><span class="math notranslate nohighlight">\(f_3\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>A</p></td>
<td><p>50</p></td>
<td><p>30</p></td>
<td><p>30</p></td>
</tr>
<tr class="row-odd"><td><p>B</p></td>
<td><p>30</p></td>
<td><p>55</p></td>
<td><p>40</p></td>
</tr>
<tr class="row-even"><td><p>C</p></td>
<td><p>30</p></td>
<td><p>20</p></td>
<td><p>50</p></td>
</tr>
<tr class="row-odd"><td><p>D</p></td>
<td><p>30</p></td>
<td><p>20</p></td>
<td><p>25</p></td>
</tr>
</tbody>
</table>
<p>Note that Solution B is better than Solution A because <span class="math notranslate nohighlight">\(f_1(A) &lt; f_1(B),\)</span>
even though A has much better values for <span class="math notranslate nohighlight">\(f_2\)</span> and <span class="math notranslate nohighlight">\(f_3\)</span>. Now,
Solution C is better B because, although <span class="math notranslate nohighlight">\(f_1(B) = f_1(C),\)</span> we have that
<span class="math notranslate nohighlight">\(f_2(B) &lt; f_2(C),\)</span> regardless of the value of <span class="math notranslate nohighlight">\(f_3.\)</span> Solution D
has the best value for all objective functions. Therefore <span class="math notranslate nohighlight">\(D &lt; C &lt; B &lt;
A.\)</span></p>
<p>In many problems in the real-life, the users usually require a particular
priority order among several objective functions, and therefore, the
lexicographical approach is very appropriate. However, if the objective
functions have no apparent order in your scenario, you may need to use a
non-dominated approach.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If you really want an algorithm to produce a <strong>non-dominated set of
solutions (Pareto frontier)</strong>, this is <strong>not</strong> the right algorithm for you.
We recommend taking a look at the <a class="reference external" href="https://doi.org/10.1109/4235.996017">NSGA-II</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/MOEA_Framework">MOAB</a>.</p>
</div>
<p>Note that we could use the single-objective version of the BRKGA, by doing a
linear (or affine) comnination of the objective function like this:</p>
<div class="math notranslate nohighlight">
\[\sum_{i = 1}^n \alpha_i f_i\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is the number of objective functions.
In the minimization case, to guarantee that
<span class="math notranslate nohighlight">\(f_i\)</span> is more important than <span class="math notranslate nohighlight">\(f_{i + 1}\)</span>, we must choose
<span class="math notranslate nohighlight">\(\alpha_i &gt; \sup(D_{i + 1})\)</span>, the supremum of set <span class="math notranslate nohighlight">\(D_{i+1}\)</span> which is
the image of <span class="math notranslate nohighlight">\(f_{i+1}\)</span>, i.e., the value <span class="math notranslate nohighlight">\(f_{i+1}\)</span> can generate.
In other words, <span class="math notranslate nohighlight">\(\alpha_i\)</span> must be larger than the highest value
<span class="math notranslate nohighlight">\(f_{i+1}\)</span> can take.</p>
<p>For instance, suppose we have two objective integer functions <span class="math notranslate nohighlight">\(f_1\)</span> and
<span class="math notranslate nohighlight">\(f_2\)</span>, for a minimization problem. Function <span class="math notranslate nohighlight">\(f_1\)</span> values vary from 0
to 10, and <span class="math notranslate nohighlight">\(f_2\)</span> varies from 100 to 500. To guarantee that a single unit
change in <span class="math notranslate nohighlight">\(f_1\)</span> is more important than all <span class="math notranslate nohighlight">\(f_2\)</span>, we must make
alpha1 = 501. Therefore, if we reduce <span class="math notranslate nohighlight">\(f_1\)</span> off one unit, this impact in
the combined objective function will be 501 units, which is larger than the
largest possible value of <span class="math notranslate nohighlight">\(f_2\)</span>.</p>
<p>The problem with this approach is that it can lead to numerical issues too fast
and too frequent for lots of practical applications. Depending on the domain of
our functions, precision errors and overflow can occur, impairing the
optimization process at all. Second, this is harder to debug and gets more work
from the developer to break the total value on every single objective value.</p>
<p>That said, to use BRKGA-MP-IPR in the native multi-objective mode,
we first must set
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1ae212772a5d4bb9b7055e30791b494514"><span class="std std-ref"><span class="pre">BRKGA::fitness_t</span></span></a></code>
according to the number of objectives we want. For that, we must
change the file
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/brkga_mp_ipr/fitness_type.hpp">fitness_type.hpp</a>
to reflect such a thing. In this example, we use the standard
<a class="reference external" href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="k">namespace</span> <span class="n">BRKGA</span> <span class="p">{</span>
<span class="linenos">2</span><span class="k">using</span> <span class="n">fitness_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="linenos">3</span><span class="p">}</span> <span class="c1">// end namespace BRKGA_MP_IPR</span>
</pre></div>
</div>
<p>In theory, we can use any custom structure or class, providing it implements
the comparison operators (<cite>operator&lt;</cite>, <cite>operator&gt;</cite>, and <cite>operator==</cite>), and the
streaming operator <cite>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const
CustomFitness&amp; fitness)</cite> where <cite>CustomFitness</cite> is your fitness structure.</p>
<p>Internally, BRKGA-MP-IPR doesn’t use <code class="docutils literal notranslate"><span class="pre">operator==</span></code> directly. BRKGA implements
the custom function
<code class="docutils literal notranslate"><a class="reference internal" href="group_utility_functions.html#doxid-group-utility-functions-1gae3eb0d56b561126f23ebd26ec556ac29"><span class="std std-ref"><span class="pre">BRKGA::close_enough()</span></span></a></code>.
For fundamental numerical types, it compares the absolute difference with a given
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1a8d1d184901bb4f34c71c7bb73a86a84a"><span class="std std-ref"><span class="pre">BRKGA::EQUALITY_THRESHOLD</span></span></a></code>
i.e., two numbers <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> equal if <span class="math notranslate nohighlight">\(|a - b| &lt;
EQUALITY\_THRESHOLD\)</span>. For all other types (except <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code>), we use
<code class="docutils literal notranslate"><span class="pre">operator==</span></code>. For <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code>, we have a specialized <code class="docutils literal notranslate"><span class="pre">close_enough()</span></code>
that iterates over each element of the tuples calling the base
<code class="docutils literal notranslate"><span class="pre">close_enough()</span></code>.</p>
<p>Once defined your <code class="docutils literal notranslate"><span class="pre">fitness_t</span></code>, you must also provide
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1a27f915fd21c02aee1097135954420ebb"><span class="std std-ref"><span class="pre">BRKGA::FITNESS_T_MIN</span></span></a></code>
and
<code class="docutils literal notranslate"><a class="reference internal" href="namespace_BRKGA.html#doxid-namespace-b-r-k-g-a-1aa4eaa93f02c949d7af918598c606402f"><span class="std std-ref"><span class="pre">BRKGA::FITNESS_T_MAX</span></span></a></code>,
if your <code class="docutils literal notranslate"><span class="pre">fitness_t</span></code> is not a fundamental type or a tuple of
fundamental types. The following is an example of a custom <code class="docutils literal notranslate"><span class="pre">fitness_t</span></code> should
looks like.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="n">MyCrazyFitness</span> <span class="p">{</span>
<span class="linenos"> 2</span><span class="k">public</span><span class="o">:</span>
<span class="linenos"> 3</span>    <span class="k">constexpr</span> <span class="n">MyCrazyFitness</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span>    <span class="k">constexpr</span> <span class="nf">MyCrazyFitness</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="n">_main_part</span><span class="p">,</span>
<span class="linenos"> 7</span>                             <span class="k">const</span> <span class="kt">double</span> <span class="n">_secondary_part</span><span class="p">,</span>
<span class="linenos"> 8</span>                             <span class="k">const</span> <span class="kt">double</span> <span class="n">_threshold</span><span class="p">)</span><span class="o">:</span>
<span class="linenos"> 9</span>        <span class="n">main_part</span><span class="p">(</span><span class="n">_main_part</span><span class="p">),</span>
<span class="linenos">10</span>        <span class="n">secondary_part</span><span class="p">(</span><span class="n">_secondary_part</span><span class="p">),</span>
<span class="linenos">11</span>        <span class="n">threshold</span><span class="p">(</span><span class="n">_threshold</span><span class="p">)</span>
<span class="linenos">12</span>        <span class="p">{}</span>
<span class="linenos">13</span>
<span class="linenos">14</span>    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">MyCrazyFitness</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="linenos">15</span>        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">main_part</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">second</span><span class="p">.</span><span class="n">main_part</span> <span class="o">-</span> <span class="n">threshold</span><span class="p">))</span>
<span class="linenos">16</span>            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="linenos">17</span>        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">secondary_part</span> <span class="o">&lt;</span> <span class="n">second</span><span class="p">.</span><span class="n">secondary_part</span><span class="p">)</span>
<span class="linenos">18</span>            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="linenos">19</span>        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="linenos">20</span>    <span class="p">}</span>
<span class="linenos">21</span>
<span class="linenos">22</span>    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">MyCrazyFitness</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="linenos">23</span>        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">main_part</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">second</span><span class="p">.</span><span class="n">main_part</span> <span class="o">+</span> <span class="n">threshold</span><span class="p">))</span>
<span class="linenos">24</span>            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="linenos">25</span>        <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">secondary_part</span> <span class="o">&gt;</span> <span class="n">second</span><span class="p">.</span><span class="n">secondary_part</span><span class="p">)</span>
<span class="linenos">26</span>            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="linenos">27</span>        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="linenos">28</span>    <span class="p">}</span>
<span class="linenos">29</span>
<span class="linenos">30</span>    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">MyCrazyFitness</span><span class="o">&amp;</span> <span class="n">second</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="linenos">31</span>        <span class="k">return</span> <span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="k">this</span> <span class="o">&lt;</span> <span class="n">second</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">&gt;</span> <span class="n">second</span><span class="p">));</span>
<span class="linenos">32</span>    <span class="p">}</span>
<span class="linenos">33</span>
<span class="linenos">34</span><span class="k">public</span><span class="o">:</span>
<span class="linenos">35</span>    <span class="kt">double</span> <span class="n">main_part</span><span class="p">;</span>
<span class="linenos">36</span>    <span class="kt">double</span> <span class="n">secondary_part</span><span class="p">;</span>
<span class="linenos">37</span>    <span class="kt">double</span> <span class="n">threshold</span><span class="p">;</span>
<span class="linenos">38</span><span class="p">};</span>
<span class="linenos">39</span>
<span class="linenos">40</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyCrazyFitness</span><span class="o">&amp;</span> <span class="n">fitness</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">41</span>    <span class="n">os</span>
<span class="linenos">42</span>    <span class="o">&lt;&lt;</span> <span class="s">&quot;(main_part: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fitness</span><span class="p">.</span><span class="n">main_part</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span>
<span class="linenos">43</span>    <span class="o">&lt;&lt;</span> <span class="s">&quot;secondary_part: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fitness</span><span class="p">.</span><span class="n">secondary_part</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span>
<span class="linenos">44</span>    <span class="o">&lt;&lt;</span> <span class="s">&quot;threshold: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fitness</span><span class="p">.</span><span class="n">threshold</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="linenos">45</span>    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="linenos">46</span><span class="p">}</span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="c1">// The following three definitions are mandatory!</span>
<span class="linenos">49</span><span class="k">using</span> <span class="n">fitness_t</span> <span class="o">=</span> <span class="n">MyCrazyFitness</span><span class="p">;</span>
<span class="linenos">50</span>
<span class="linenos">51</span><span class="k">static</span> <span class="k">constexpr</span> <span class="n">fitness_t</span> <span class="n">FITNESS_T_MIN</span> <span class="p">{</span><span class="o">-</span><span class="mf">100.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">1e-16</span><span class="p">};</span>
<span class="linenos">52</span>
<span class="linenos">53</span><span class="k">static</span> <span class="k">constexpr</span> <span class="n">fitness_t</span> <span class="n">FITNESS_T_MAX</span> <span class="p">{</span><span class="mf">1000.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">};</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Unless we really need a custom <code class="docutils literal notranslate"><span class="pre">fitness_t</span></code>, you should use <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code>.</p>
</div>
</section>
<section id="probable-valuable-tips">
<span id="doxid-guide-guide-tips"></span><h2>(Probable Valuable) Tips<a class="headerlink" href="#probable-valuable-tips" title="Link to this heading"></a></h2>
<section id="algorithm-warmup">
<span id="doxid-guide-algorithm-warmup"></span><h3>Algorithm warmup<a class="headerlink" href="#algorithm-warmup" title="Link to this heading"></a></h3>
<p>While in Julia framework version is primordial to do a dry-run to precompile
all functions (and a good idea on Python version), in C++ and Python this
warmup is not necessary. However, few dry-runs can help the OS/processor with
cache locality and give some speedup.</p>
<p>Besides the dry-runs, I would recommend the pre-allocation of all
resource/memory that you need, if you know in advance how much will be
necessary. This pre-allocation speeds the decoding process dramatically.
There is
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/issues/3#issuecomment-986107579">some argument</a>.
whether or not we should pre-allocate some data
structures since it might incur
<a class="reference external" href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a>.
Therefore, more experimentation and fine-tuning are needed in this space.</p>
</section>
<section id="complex-decoders-and-timing">
<span id="doxid-guide-complex-decoders-and-timing"></span><h3>Complex decoders and timing<a class="headerlink" href="#complex-decoders-and-timing" title="Link to this heading"></a></h3>
<p>Some problems require complex decoders while for others, the decoder contains
local search procedures, that can be time-consuming. In general, the decoding
is the most time-expensive component of a BRKGA algorithm, and it may skew some
stopping criteria based on running time. Therefore, if your decoder is
time-consuming, it is a good idea to implement a timer or chronometer kind of
thing inside the decoder.</p>
<p>Testing for stopping time uses several CPU cycles, and you need to be careful
when/where to test it, otherwise, you spend all the optimization time doing
system calls to the clock.</p>
<p>IMHO, the most effective way to do it is to test time at the very begining of
the decoding. If the current time is larger than the maximum time allowed,
simple return <code class="docutils literal notranslate"><span class="pre">Inf</span></code> or <code class="docutils literal notranslate"><span class="pre">-Inf</span></code> according to your optimization direction. In
this way, we make the solution <strong>invalid</strong> since it violates the maximum time
allowed. The BRKGA framework takes care of the rest.</p>
</section>
<section id="multi-thread-decoding">
<span id="doxid-guide-guide-tips-multi-thread-decoding"></span><h3>Multi-thread decoding<a class="headerlink" href="#multi-thread-decoding" title="Link to this heading"></a></h3>
<p>Since <a class="reference external" href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore’s law</a> is not
holding its status anymore, we, simple mortals, must appeal to the wonders of
multi-threading. This paradigm can be tricky to code, and <a class="reference external" href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a> plays against us. Several
genetic algorithms, and in particular, BRKGA, can use parallel solution
evaluation (or decoding), which makes the use of multi-threading relatively
straightforward. BRKGA-MP-IPR C++ framework is not different, and it uses
<a class="reference external" href="https://www.openmp.org">OpenMP</a> capabilities to do so.</p>
<p>First, as commented several times in this guide, <strong>the decoder must be
THREAD-SAFE.</strong> So, each thread must have its own read/write data structures and
may share other read-only data. The simplest way to do it is to create those
structures inside the decoder (like most people do). <strong>But be aware</strong>, this
strategy slows down the algorithm significantly depending on the size and
format of the structures, and <em>I do not recommend it</em>.</p>
<p>IMHO, the best way to do that is to preallocate the data structure per thread
and pass them to the decoder through the problem instance. Then, inside the
decoder, you can use <a class="reference external" href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-5.0.pdf">omp_get_thread_num()</a>
and recover the memory you want to use.</p>
<p>Let’s see a simple example considering the TSP example. <code class="docutils literal notranslate"><span class="pre">TSP_Decode</span></code> uses a
single array to create the permutation of nodes. Let’s pre-allocate its memory
per thread. To keep things separeted and easy to understand, we created a new
class
<a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/decoders/tsp_decoder_pre_allocating.hpp">TSP_Decoder_pre_allocating</a>
so that we allocate, for each thread, a vector to hold the permutation during
the decoding:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">class</span> <span class="n">TSP_Decoder_pre_allocating</span> <span class="p">{</span>
<span class="linenos"> 2</span><span class="k">public</span><span class="o">:</span>
<span class="linenos"> 3</span>    <span class="n">TSP_Decoder_pre_allocating</span><span class="p">(</span><span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">,</span>
<span class="linenos"> 4</span>                               <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">num_threads</span> <span class="o">=</span> <span class="mi">1</span><span class="p">);</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span>    <span class="kt">double</span> <span class="nf">decode</span><span class="p">(</span><span class="n">BRKGA</span><span class="o">::</span><span class="n">Chromosome</span> <span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">rewrite</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="k">public</span><span class="o">:</span>
<span class="linenos"> 9</span>    <span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">;</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="k">protected</span><span class="o">:</span>
<span class="linenos">12</span>    <span class="k">using</span> <span class="n">Permutation</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="linenos">13</span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Permutation</span><span class="o">&gt;</span> <span class="n">permutation_per_thread</span><span class="p">;</span>
<span class="linenos">14</span><span class="p">};</span>
</pre></div>
</div>
<p>Note that the constructor has one more argument indicating how many threads we
are using. We also define a type <code class="docutils literal notranslate"><span class="pre">Permutation</span></code> with is a simple vector of
key-node pairs. The important structure is <code class="docutils literal notranslate"><span class="pre">permuration_per_thread</span></code> which is
a simple vector of the size of the number of threads where we allocate the
permutation vectors for each thread.</p>
<p>Then, in the implementation, we allocate all memory in the constructor
(<a class="reference external" href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII principle</a>).
In <code class="docutils literal notranslate"><span class="pre">decode</span></code>, we use <a class="reference external" href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-5.0.pdf">omp_get_thread_num()</a>
to identify which thread called the decoder, and retrieve the respective data
strucuture.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span> <span class="cpf">&lt;omp.h&gt;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="n">TSP_Decoder_pre_allocating</span><span class="o">::</span><span class="n">TSP_Decoder_pre_allocating</span><span class="p">(</span>
<span class="linenos"> 4</span>            <span class="k">const</span> <span class="n">TSP_Instance</span><span class="o">&amp;</span> <span class="n">_instance</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">num_threads</span><span class="p">)</span><span class="o">:</span>
<span class="linenos"> 5</span>    <span class="n">instance</span><span class="p">(</span><span class="n">_instance</span><span class="p">),</span>
<span class="linenos"> 6</span>    <span class="c1">// Pre-allocate space for permutations for each thread.</span>
<span class="linenos"> 7</span>    <span class="n">permutation_per_thread</span><span class="p">(</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">))</span>
<span class="linenos"> 8</span><span class="p">{}</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="kt">double</span> <span class="n">TSP_Decoder_pre_allocating</span><span class="o">::</span><span class="n">decode</span><span class="p">(</span><span class="n">Chromosome</span><span class="o">&amp;</span> <span class="n">chromosome</span><span class="p">,</span>
<span class="linenos">11</span>                                          <span class="kt">bool</span> <span class="cm">/* not-used */</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">12</span>    <span class="c1">// If you have OpenMP available, get the allocated memory per thread ID.</span>
<span class="linenos">13</span>    <span class="cp">#ifdef _OPENMP</span>
<span class="linenos">14</span>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">permutation</span> <span class="o">=</span> <span class="n">permutation_per_thread</span><span class="p">[</span><span class="n">omp_get_thread_num</span><span class="p">()];</span>
<span class="linenos">15</span>    <span class="cp">#else</span>
<span class="linenos">16</span>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">permutation</span> <span class="o">=</span> <span class="n">permutation_per_thread</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="linenos">17</span>    <span class="cp">#endif</span>
<span class="linenos">18</span>
<span class="linenos">19</span>    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="linenos">20</span>        <span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">chromosome</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
<span class="linenos">21</span>
<span class="linenos">22</span>    <span class="n">sort</span><span class="p">(</span><span class="n">permutation</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">permutation</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="linenos">23</span>
<span class="linenos">24</span>    <span class="kt">double</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">permutation</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">,</span>
<span class="linenos">25</span>                                    <span class="n">permutation</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">second</span><span class="p">);</span>
<span class="linenos">26</span>
<span class="linenos">27</span>    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">instance</span><span class="p">.</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="linenos">28</span>        <span class="n">cost</span> <span class="o">+=</span> <span class="n">instance</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">permutation</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">,</span>
<span class="linenos">29</span>                                  <span class="n">permutation</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
<span class="linenos">30</span>
<span class="linenos">31</span>    <span class="k">return</span> <span class="n">cost</span><span class="p">;</span>
<span class="linenos">32</span><span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Pre-allocation and multi-threading only make sense for large data structures
and time-consuming decoders. Otherwise, the code spends too much time on
context switching and system calls.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Multi-threading consumes many resources of the machine and have diminishing
returns. I recommend using <strong>at most the number of physical cores</strong> (may -1)
to avoid racing and too much context switching. You must test which is the
best option for your case. In my experience, complex decoders benefit more
from multi-threading than simple and fast decoders.</p>
</div>
</section>
<section id="multi-thread-mating">
<span id="doxid-guide-guide-tips-multi-thread-mating"></span><h3>Multi-thread mating<a class="headerlink" href="#multi-thread-mating" title="Link to this heading"></a></h3>
<p>One of the nice additions to BRKGA-MP-IPR 2.0 is the capability of performing
the mating in parallel. Such capability speeds up the algorithm substantially,
mainly for large chromosomes and large populations. However, when performing
parallel mating, we have some points regarding reproducibility described below.
The parallel mating is controlled in compilation time by the preprocessing flags
<code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga232080cffcccb7698dd33155c0a534d7"><span class="std std-ref"><span class="pre">MATING_FULL_SPEED</span></span></a></code>,
<code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga68b3cb7d49905ea1096c35a4467b6c22"><span class="std std-ref"><span class="pre">MATING_SEED_ONLY</span></span></a></code>,
and
<code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga5766b15b52c6201d58440c53462fdf24"><span class="std std-ref"><span class="pre">MATING_SEQUENTIAL</span></span></a></code>,</p>
<p>Compiling your code with
<code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga5766b15b52c6201d58440c53462fdf24"><span class="std std-ref"><span class="pre">MATING_SEQUENTIAL</span></span></a></code>,
enabled will remove the parallel mating at all, and the algorithm will behave
like the previous versions. This option can be very slow for large chromosomes
and large populations. But it makes debugging easier. Following we have a quick
example using the TSP decoder with 4 threads, for 1,000 generations. We only
run the evolutionary portion, disabling all other features
(see <a class="reference external" href="https://github.com/ceandrade/brkga_mp_ipr_cpp/blob/master/examples/tsp/src/single_obj/main_maximum_iterations.cpp">main_maximum_iterations.cpp</a>).
Note that the average total time (real time) is 4m 46s.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ make
...
...
g++ -DMATING_SEQUENTIAL -std=c++20 -O3 -fomit-frame-pointer -funroll-loops \
    -ftracer -fpeel-loops -fprefetch-loop-arrays -pthread -fopenmp \
    -I. -I./brkga_mp_ipr  -c main_maximum_iterations.cpp -o main_maximum_iterations.o
...

$ for i in 1 2 3; do time ./main_maximum_iterations 270001 config.conf 1000 ../../instances/rd400.dat &gt; /dev/null; done

real    4m48.649s
user    6m58.208s
sys     0m0.432s

real    4m42.132s
user    6m48.032s
sys     0m0.418s

real    4m46.317s
user    6m53.796s
sys     0m0.243s
</pre></div>
</div>
<p>Setting
<code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga68b3cb7d49905ea1096c35a4467b6c22"><span class="std std-ref"><span class="pre">MATING_SEED_ONLY</span></span></a></code>,
BRKGA will perform the mating in parallel, however, in
a more controlled way. On each evolutionary step, the algorithm creates a
sequence of seeds (one per to-be-generated offspring). Such seeds are fed to a
pseudo-random number generator (RNG) for each thread: when starting the mating,
the RNG is seeded before being used. This occurs in each iteration. In this way,
all generators have their state controlled by the main generator, and therefore,
<strong>the unique seed</strong> supplied by the user. This is another example, running the
same machine and also 4 threads. The average total time is 1m 58s, a whooping
reduction of ~59%.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ make
...
...
g++ -DMATING_SEED_ONLY -std=c++20 -O3 -fomit-frame-pointer -funroll-loops \
    -ftracer -fpeel-loops -fprefetch-loop-arrays -pthread -fopenmp \
    -I. -I./brkga_mp_ipr  -c main_maximum_iterations.cpp -o main_maximum_iterations.o
...

$ for i in 1 2 3; do time ./main_maximum_iterations 270001 config.conf 1000 ../../instances/rd400.dat &gt; /dev/null; done

real    1m58.493s
user    7m34.826s
sys     0m2.335s

real    1m57.311s
user    7m38.627s
sys     0m0.941s

real    1m57.403s
user    7m47.691s
sys     0m0.950s
</pre></div>
</div>
<p>Finally,
<code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga232080cffcccb7698dd33155c0a534d7"><span class="std std-ref"><span class="pre">MATING_FULL_SPEED</span></span></a></code>,
enables parallel mating at full speed. In this case,
each thread has a unique RNG previously seeded at the beginning of the algorithm
(BRKGA constructor). This initialization is done in a chain: the first RNG is
seeded with the seed provided by the user. For the following, the algorithm uses
the previous RNG state as seed. In this way, we guarantee that all RNGs have
different states, but all depend on the user seed. However, in this case, <strong>the
reproducibility depends on both the seed given by the user and the number of
threads</strong>. This is because to guarantee reproducibility, we must ensure that the
same chromosome region is handled by the same thread (id) since we have an RNG
per thread. In other words, the random states must be the same for each thread,
on different runs.  When we increase or decrease the number of threads,
different threads will handle the chromosomes. However, this is the fastest
method. Here is another example, using the same conditions as before.
The average here is 1m 56s, a marginal improve regarding to
<code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga68b3cb7d49905ea1096c35a4467b6c22"><span class="std std-ref"><span class="pre">MATING_SEED_ONLY</span></span></a></code>,</p>
<pre class="highlight literal-block"><span></span>$ make
...
...
g++ -DMATING_FULL_SPEED -std=c++20 -O3 -fomit-frame-pointer -funroll-loops \
    -ftracer -fpeel-loops -fprefetch-loop-arrays -pthread -fopenmp \
    -I. -I./brkga_mp_ipr  -c main_maximum_iterations.cpp -o main_maximum_iterations.o
...

$ for i in 1 2 3; do time ./main_maximum_iterations 270001 config.conf 1000 ../../instances/rd400.dat &gt; /dev/null; done

real    1m55.840s
user    7m40.191s
sys     0m1.382s

real    1m56.824s
user    7m44.251s
sys     0m0.845s

real    1m56.293s
user    7m41.350s
sys     0m2.114s</pre>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Remember, when using
<code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga232080cffcccb7698dd33155c0a534d7"><span class="std std-ref"><span class="pre">MATING_FULL_SPEED</span></span></a></code>,
the results depend on both <strong>seed</strong> and <strong>number of threads.</strong>
Multiple runs with the same seed and number of threads should produce the
same results. Changing one or other, the results will change.</p>
</div>
<p>Of course, these results depend on the problem and decoder implementation. But
you can see that, or simple/fast decoders, both parallel options represent a
very significant improvement over the serial version.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We thank <a class="reference external" href="https://github.com/afkummer">Alberto F. Kummer</a>
very much for the first version of the parallel mating and the fruitful
discussions about it and other topics. Please, also consider citing his
paper <span id="id27">[<a class="reference internal" href="#id67" title="Alberto F. Kummer N. and Luciana S. Buriol Olinto C. B. Araújo. A biased random key genetic algorithm applied to the vrptw with skill requirements and synchronization constraints. In Proceedings of the 2020 Genetic and Evolutionary Computation Conference, GECCO '20, 717–724. New York, NY, USA, 2020. Association for Computing Machinery. doi:10.1145/3377930.3390209.">NA20</a>]</span>.</p>
</div>
</section>
</section>
<section id="known-issues">
<span id="doxid-guide-known-issues"></span><h2>Known issues<a class="headerlink" href="#known-issues" title="Link to this heading"></a></h2>
<p>Since BRKGA-MP-IPR is header-only, we may have compilation/linking issues if we
include the BRKGA-MP-IPR header in different modules (translation units on C++
jargon) and compile them separately (which normally we do). For example,
suppose we have two pieces of code, module_a.cpp and module_b.cpp, such that we
include BRKGA in both (i.e., <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;brkga_mp_ipr&quot;</span></code> in both files.</p>
<p>File <cite>module_a.cpp</cite>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="cp">#include</span> <span class="cpf">&quot;brkga_mp_ipr.hpp&quot;</span>
<span class="linenos">2</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="linenos">3</span>    <span class="k">auto</span> <span class="n">params</span> <span class="o">=</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">readConfiguration</span><span class="p">(</span><span class="s">&quot;config.conf&quot;</span><span class="p">);</span>
<span class="linenos">4</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="linenos">5</span><span class="p">}</span>
</pre></div>
</div>
<p>File <cite>module_b.cpp</cite>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="cp">#include</span> <span class="cpf">&quot;brkga_mp_ipr.hpp&quot;</span>
<span class="linenos">2</span><span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
<span class="linenos">3</span>    <span class="k">auto</span> <span class="n">params</span> <span class="o">=</span> <span class="n">BRKGA</span><span class="o">::</span><span class="n">readConfiguration</span><span class="p">(</span><span class="s">&quot;config.conf&quot;</span><span class="p">);</span>
<span class="linenos">4</span><span class="p">}</span>
</pre></div>
</div>
<p>Let’s compile each one with GCC and link them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span>$ g++ -std=c++20 -I../brkga_mp_ipr -c module_a.cpp -o module_a.o
<span class="linenos"> 2</span>
<span class="linenos"> 3</span>$ g++ -std=c++20 -I../brkga_mp_ipr -c module_b.cpp -o module_b.o
<span class="linenos"> 4</span>
<span class="linenos"> 5</span>$ g++ module_a.o module_b.o -o test
<span class="linenos"> 6</span>
<span class="linenos"> 7</span>duplicate symbol &#39;__ZN5BRKGA6EnumIOINS_13PathRelinking9SelectionEE10enum_namesB5cxx11Ev&#39; in:
<span class="linenos"> 8</span>    module_a.o
<span class="linenos"> 9</span>    module_b.o
<span class="linenos">10</span>duplicate symbol &#39;__ZN5BRKGA6EnumIOINS_5SenseEE10enum_namesB5cxx11Ev&#39; in:
<span class="linenos">11</span>    module_a.o
<span class="linenos">12</span>    module_b.o
<span class="linenos">13</span>duplicate symbol &#39;__ZN5BRKGA6EnumIOINS_16BiasFunctionTypeEE10enum_namesB5cxx11Ev&#39; in:
<span class="linenos">14</span>    module_a.o
<span class="linenos">15</span>    module_b.o
<span class="linenos">16</span>duplicate symbol &#39;__ZN5BRKGA6EnumIOINS_13PathRelinking20DistanceFunctionTypeEE10enum_namesB5cxx11Ev&#39; in:
<span class="linenos">17</span>    module_a.o
<span class="linenos">18</span>    module_b.o
<span class="linenos">19</span>duplicate symbol &#39;__ZN5BRKGA6EnumIOINS_11ShakingTypeEE10enum_namesB5cxx11Ev&#39; in:
<span class="linenos">20</span>    module_a.o
<span class="linenos">21</span>    module_b.o
<span class="linenos">22</span>duplicate symbol &#39;__ZN5BRKGA6EnumIOINS_13PathRelinking4TypeEE10enum_namesB5cxx11Ev&#39; in:
<span class="linenos">23</span>    module_a.o
<span class="linenos">24</span>    module_b.o
<span class="linenos">25</span>duplicate symbol &#39;__ZN5BRKGA17readConfigurationERSiRSo&#39; in:
<span class="linenos">26</span>    module_a.o
<span class="linenos">27</span>    module_b.o
<span class="linenos">28</span>duplicate symbol &#39;__ZN5BRKGA17readConfigurationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSo&#39; in:
<span class="linenos">29</span>    module_a.o
<span class="linenos">30</span>    module_b.o
<span class="linenos">31</span>duplicate symbol &#39;__ZN5BRKGAlsERSoRKNS_15AlgorithmStatusE&#39; in:
<span class="linenos">32</span>    module_a.o
<span class="linenos">33</span>    module_b.o
<span class="linenos">34</span>duplicate symbol &#39;__ZN5BRKGAlsERSoRKNS_13ControlParamsE&#39; in:
<span class="linenos">35</span>    module_a.o
<span class="linenos">36</span>    module_b.o
<span class="linenos">37</span>duplicate symbol &#39;__ZN5BRKGA18writeConfigurationERSoRKNS_11BrkgaParamsERKNS_13ControlParamsE&#39; in:
<span class="linenos">38</span>    module_a.o
<span class="linenos">39</span>    module_b.o
<span class="linenos">40</span>duplicate symbol &#39;__ZN5BRKGA18writeConfigurationERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11BrkgaParamsERKNS_13ControlParamsE&#39; in:
<span class="linenos">41</span>    module_a.o
<span class="linenos">42</span>    module_b.o
<span class="linenos">43</span>duplicate symbol &#39;__ZN5BRKGAlsERSoRKNS_11BrkgaParamsE&#39; in:
<span class="linenos">44</span>    module_a.o
<span class="linenos">45</span>    module_b.o
<span class="linenos">46</span>ld: 13 duplicate symbols for architecture x86_64
<span class="linenos">47</span>collect2: error: ld returned 1 exit status
</pre></div>
</div>
<p>Now, we try with Clang:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span>$ clang++ -std=c++20 -fopenmp -I../brkga_mp_ipr -c module_a.cpp -o module_a.o
<span class="linenos"> 2</span>
<span class="linenos"> 3</span>$ clang++ -std=c++20 -fopenmp -I../brkga_mp_ipr -c module_b.cpp -o module_b.o
<span class="linenos"> 4</span>
<span class="linenos"> 5</span>$ clang++ -std=c++20 -fopenmp module_a.o module_b.o -o test
<span class="linenos"> 6</span>
<span class="linenos"> 7</span>duplicate symbol &#39;BRKGA::EnumIO&lt;BRKGA::PathRelinking::Selection&gt;::enum_names()&#39; in:
<span class="linenos"> 8</span>    module_a.o
<span class="linenos"> 9</span>    module_b.o
<span class="linenos">10</span>duplicate symbol &#39;BRKGA::EnumIO&lt;BRKGA::Sense&gt;::enum_names()&#39; in:
<span class="linenos">11</span>    module_a.o
<span class="linenos">12</span>    module_b.o
<span class="linenos">13</span>duplicate symbol &#39;BRKGA::EnumIO&lt;BRKGA::BiasFunctionType&gt;::enum_names()&#39; in:
<span class="linenos">14</span>    module_a.o
<span class="linenos">15</span>    module_b.o
<span class="linenos">16</span>duplicate symbol &#39;BRKGA::EnumIO&lt;BRKGA::PathRelinking::DistanceFunctionType&gt;::enum_names()&#39; in:
<span class="linenos">17</span>    module_a.o
<span class="linenos">18</span>    module_b.o
<span class="linenos">19</span>duplicate symbol &#39;BRKGA::EnumIO&lt;BRKGA::ShakingType&gt;::enum_names()&#39; in:
<span class="linenos">20</span>    module_a.o
<span class="linenos">21</span>    module_b.o
<span class="linenos">22</span>duplicate symbol &#39;BRKGA::EnumIO&lt;BRKGA::PathRelinking::Type&gt;::enum_names()&#39; in:
<span class="linenos">23</span>    module_a.o
<span class="linenos">24</span>    module_b.o
<span class="linenos">25</span>duplicate symbol &#39;BRKGA::operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, BRKGA::AlgorithmStatus const&amp;)&#39; in:
<span class="linenos">26</span>    module_a.o
<span class="linenos">27</span>    module_b.o
<span class="linenos">28</span>duplicate symbol &#39;BRKGA::writeConfiguration(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, BRKGA::BrkgaParams const&amp;, BRKGA::ControlParams const&amp;)&#39; in:
<span class="linenos">29</span>    module_a.o
<span class="linenos">30</span>    module_b.o
<span class="linenos">31</span>duplicate symbol &#39;BRKGA::writeConfiguration(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;, BRKGA::BrkgaParams const&amp;, BRKGA::ControlParams const&amp;)&#39; in:
<span class="linenos">32</span>    module_a.o
<span class="linenos">33</span>    module_b.o
<span class="linenos">34</span>duplicate symbol &#39;BRKGA::operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, BRKGA::ControlParams const&amp;)&#39; in:
<span class="linenos">35</span>    module_a.o
<span class="linenos">36</span>    module_b.o
<span class="linenos">37</span>duplicate symbol &#39;BRKGA::operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, BRKGA::BrkgaParams const&amp;)&#39; in:
<span class="linenos">38</span>    module_a.o
<span class="linenos">39</span>    module_b.o
<span class="linenos">40</span>duplicate symbol &#39;BRKGA::readConfiguration(std::__1::basic_istream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;)&#39; in:
<span class="linenos">41</span>    module_a.o
<span class="linenos">42</span>    module_b.o
<span class="linenos">43</span>duplicate symbol &#39;BRKGA::readConfiguration(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt;&gt; const&amp;, std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;)&#39; in:
<span class="linenos">44</span>    module_a.o
<span class="linenos">45</span>    module_b.o
<span class="linenos">46</span>duplicate symbol &#39;operator&lt;&lt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt;&gt;&amp;, std::__1::chrono::duration&lt;double, std::__1::ratio&lt;1l, 1l&gt;&gt; const&amp;)&#39; in:
<span class="linenos">47</span>    module_a.o
<span class="linenos">48</span>    module_b.o
<span class="linenos">49</span>ld: 14 duplicate symbols for architecture x86_64
<span class="linenos">50</span>clang: error: linker command failed with exit code 1 (use -v to see invocation)
</pre></div>
</div>
<p>So, note that we have several duplicated symbols (which varies a little bit
per compiler), including the EnumIO utilities, output stream operators,
<code class="docutils literal notranslate"><a class="reference internal" href="group_brkga_control_params.html#doxid-group-brkga-control-params-1ga1c8b456ad75a3b522d315d4167546ae6"><span class="std std-ref"><span class="pre">BRKGA::readConfiguration()</span></span></a></code>,
<code class="docutils literal notranslate"><a class="reference internal" href="group_brkga_control_params.html#doxid-group-brkga-control-params-1ga758c489d2f6291cf80a78ca6765b856e"><span class="std std-ref"><span class="pre">BRKGA::writeConfiguration()</span></span></a></code>,
even the definitions of
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_AlgorithmStatus.html#doxid-class-b-r-k-g-a-1-1-algorithm-status"><span class="std std-ref"><span class="pre">BRKGA::AlgorithmStatus</span></span></a></code>,
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_BrkgaParams.html#doxid-class-b-r-k-g-a-1-1-brkga-params"><span class="std std-ref"><span class="pre">BRKGA::BrkgaParams</span></span></a></code>,
and
<code class="docutils literal notranslate"><a class="reference internal" href="class_BRKGA_ControlParams.html#doxid-class-b-r-k-g-a-1-1-control-params"><span class="std std-ref"><span class="pre">BRKGA::ControlParams</span></span></a></code>.</p>
<p>To avoid such a situation, we have to <code class="docutils literal notranslate"><span class="pre">inline</span></code> these functions and template
specializations. We can do that passing the compiler directive
<code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga608f9e381594efac6848d962c0110e91"><span class="std std-ref"><span class="pre">BRKGA_MULTIPLE_INCLUSIONS</span></span></a></code>,
which inlines the functions and template specializations properly.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ g++ -std=c++20 -I../brkga_mp_ipr -DBRKGA_MULTIPLE_INCLUSIONS -c module_a.cpp -o module_a.o

$ g++ -std=c++20 -I../brkga_mp_ipr -DBRKGA_MULTIPLE_INCLUSIONS -c module_b.cpp -o module_b.o

$ g++ module_a.o module_b.o -o test
</pre></div>
</div>
<p>However, we have two side-effects. First, such inlining can make the object
code grows large since we include several copies of the same functions (which
are I/O functions which already are large by their nature). Second, the
compiler may complain about too many inline functions, if you are already using
several inline functions.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Avoid including <code class="docutils literal notranslate"><span class="pre">brkga_mp_ip.hpp</span></code> in several files/translation units.
If unavoidable, use the compiler directive <code class="docutils literal notranslate"><a class="reference internal" href="group_compiler_directives.html#doxid-group-compiler-directives-1ga608f9e381594efac6848d962c0110e91"><span class="std std-ref"><span class="pre">BRKGA_MULTIPLE_INCLUSIONS</span></span></a></code>.</p>
</div>
<p>But now, suppose we must use multiple inclusions of BRKGA header, and our
compiler finds issues on inline such functions. The last resource is to move
the implementation of such functions to a separated translation unit (.cpp)
and compile them isolated, adding to the linking stage.</p>
</section>
<section id="references">
<span id="doxid-guide-references"></span><h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<div class="docutils container" id="id28">
<div role="list" class="citation-list">
<div class="citation" id="id31" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>APS22<span class="fn-bracket">]</span></span>
<p>Carlos E. Andrade, Lucia S. Pessoa, and Slawomir Stawiarski. The physical cell identity assignment problem: a practical optimization approach. <em>IEEE Transactions on Evolutionary Computation</em>, ():1–1, 2022. To appear. <a class="reference external" href="https://doi.org/10.1109/TEVC.2022.3185927">doi:10.1109/TEVC.2022.3185927</a>.</p>
</div>
<div class="citation" id="id37" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ASP19<span class="fn-bracket">]</span></span>
<p>Carlos E. Andrade, Thuener Silva, and Luciana S. Pessoa. Minimizing flowtime in a flowshop scheduling problem with a biased random-key genetic algorithm. <em>Expert Systems with Applications</em>, 128:67–80, Aug 2019. <a class="reference external" href="https://doi.org/10.1016/j.eswa.2019.03.007">doi:10.1016/j.eswa.2019.03.007</a>.</p>
</div>
<div class="citation" id="id34" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ATGR21<span class="fn-bracket">]</span></span>
<p>Carlos E. Andrade, Rodrigo F. Toso, José F. Gonçalves, and Mauricio G. C. Resende. The multi-parent biased random-key genetic algorithm with implicit path-relinking and its real-world applications. <em>European Journal of Operational Research</em>, 289(1):17–30, 2021. <a class="reference external" href="https://doi.org/10.1016/j.ejor.2019.11.037">doi:10.1016/j.ejor.2019.11.037</a>.</p>
</div>
<div class="citation" id="id41" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>ATRM15<span class="fn-bracket">]</span></span>
<p>Carlos E. Andrade, Rodrigo F. Toso, Mauricio G. C. Resende, and Flávio K. Miyazawa. Biased random-key genetic algorithms for the winner determination problem in combinatorial auctions. <em>Evolutionary Computation</em>, 23:279–307, 2015. <a class="reference external" href="https://doi.org/10.1162/EVCO_a_00138">doi:10.1162/EVCO_a_00138</a>.</p>
</div>
<div class="citation" id="id65" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HCdM18<span class="fn-bracket">]</span></span>
<p>William Higino, Antônio Augusto Chaves, and Vinicius Veloso de Melo. Biased random-key genetic algorithm applied to the vehicle routing problem with private fleet and common carrier. <em>2018 IEEE Congress on Evolutionary Computation (CEC)</em>, pages 1–8, 2018. <a class="reference external" href="https://doi.org/10.1109/CEC.2018.8477905">doi:10.1109/CEC.2018.8477905</a>.</p>
</div>
<div class="citation" id="id40" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>LAQ+16<span class="fn-bracket">]</span></span>
<p>Mauro C. Lopes, Carlos E. Andrade, Thiago A. Queiroz, Mauricio G. C. Resende, and Flávio K. Miyazawa. Heuristics for a hub location-routing problem. <em>Networks</em>, 68(1):54–90, 2016. <a class="reference external" href="https://doi.org/10.1002/net.21685">doi:10.1002/net.21685</a>.</p>
</div>
<div class="citation" id="id64" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>MWKA07<span class="fn-bracket">]</span></span>
<p>Makoto Matsumoto, Isaku Wada, Ai Kuramoto, and Hyo Ashihara. Common defects in initialization of pseudorandom number generators. <em>ACM Trans. Model. Comput. Simul.</em>, 17(4):15–es, sep 2007. <a class="reference external" href="https://doi.org/10.1145/1276927.1276928">doi:10.1145/1276927.1276928</a>.</p>
</div>
<div class="citation" id="id67" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>NA20<span class="fn-bracket">]</span></span>
<p>Alberto F. Kummer N. and Luciana S. Buriol Olinto C. B. Araújo. A biased random key genetic algorithm applied to the vrptw with skill requirements and synchronization constraints. In <em>Proceedings of the 2020 Genetic and Evolutionary Computation Conference</em>, GECCO '20, 717–724. New York, NY, USA, 2020. Association for Computing Machinery. <a class="reference external" href="https://doi.org/10.1145/3377930.3390209">doi:10.1145/3377930.3390209</a>.</p>
</div>
<div class="citation" id="id38" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>PA18<span class="fn-bracket">]</span></span>
<p>Luciana S. Pessoa and Carlos E. Andrade. Heuristics for a flowshop scheduling problem with stepwise job objective function. <em>European Journal of Operational Research</em>, 266(3):950–962, 2018. <a class="reference external" href="https://doi.org/10.1016/j.ejor.2017.10.045">doi:10.1016/j.ejor.2017.10.045</a>.</p>
</div>
<div class="citation" id="id66" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>WRH98<span class="fn-bracket">]</span></span>
<p>Darrell Whitley, Soraya Rana, and Robert B. Heckendorn. The island model genetic algorithm: On separability, population size and convergence. <em>Journal of Computing and Information Technology</em>, 7:33–47, 1998. URL: <a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.7225">https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.7225</a>.</p>
</div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="BRKGA-MP-IPR Guide and Documentation - C++ Version 3.0" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="page_license.html" class="btn btn-neutral float-right" title="BRKGA-MP-IPR License" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2023, Carlos E. Andrade.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>